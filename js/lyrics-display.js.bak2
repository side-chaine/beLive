/**
 * Lyrics Display for Text application
 * Handles displaying and synchronizing lyrics with audio
 */

class LyricsDisplay {
    constructor() {
        this.lyricsContainer = document.getElementById('lyrics-display');
        this.containerElement = document.getElementById('lyrics-container');
        this.currentLine = 0;
        this.lyrics = [];
        this.currentLyricElement = null;
        this.fullText = '';
        this.duration = 0;
        this.autoScrollEnabled = true;
        this.lastScrollTime = 0;
        this._usingLinkinParkMap = false;
        this._lastEditModeState = false;  // Track edit mode state changes
        
        // Add style properties
        this.currentStyle = null; // Current applied style
        this.styleClasses = {}; // Store applied style classes
        this.appliedStyleClasses = []; // List of currently applied style classes
        this.currentlyFocusedBlockId = null; // ADDED: To track the currently focused block in rehearsal mode
        
        // Block mode properties
        this.textBlocks = []; // Stores defined blocks: [{ id: string, name: string, lineIndices: number[] }]
        this.currentBlockCreation = []; // Stores line indices for the block currently being created
        this.isInBlockMode = false; // True if block creation UI is active
        
        // Initialize event listeners for manual scrolling
        this._initScrollListeners();
        
        // Initialize touch handlers for mobile
        this._initTouchHandlers();
        
        // Flag to track if we're using the marker manager
        this.usingMarkerManager = false;
        
        // Configuration options
        this.options = {
            autoScroll: true, // Auto-scroll to keep active line in view
            showControls: true, // Show lyrics control buttons
            highlightActive: true, // Highlight active line
            scrollBehavior: 'smooth' // Smooth scrolling
        };
        
        console.log('LyricsDisplay initialized');
    }
    
    _initScrollListeners() {
        // Skip if container doesn't exist
        if (!this.containerElement) return;
        
        // Initialize last scroll time
        this.lastScrollTime = 0;
        this._userInitiatedScroll = false;
        
        // Detect manual scrolling with wheel events
        this.containerElement.addEventListener('wheel', (e) => {
            // Mark this as a user-initiated scroll
            this._userInitiatedScroll = true;
            
            // Disable auto-scroll for a short period after manual scroll
            this.autoScrollEnabled = false;
            this.lastScrollTime = Date.now();
            
            // Re-enable auto-scroll after 4 seconds of no scrolling
            clearTimeout(this.scrollTimeout);
            this.scrollTimeout = setTimeout(() => {
                this.autoScrollEnabled = true;
                this._userInitiatedScroll = false;
                console.log("Auto-scroll re-enabled after timeout");
            }, 4000);
        }, { passive: true });
        
        // Also detect scroll events (for scrollbar dragging or momentum scrolling)
        this.containerElement.addEventListener('scroll', () => {
            if (this._userInitiatedScroll || !this.usingMarkerManager) {
                // Only update the timestamp if this is a user-initiated scroll
                // or we're not using marker manager (to avoid conflicts)
                this.lastScrollTime = Date.now();
                
                if (this.autoScrollEnabled) {
                    this.autoScrollEnabled = false;
                    
                    // Re-enable auto-scroll after 4 seconds
                    clearTimeout(this.scrollTimeout);
                    this.scrollTimeout = setTimeout(() => {
                        this.autoScrollEnabled = true;
                        this._userInitiatedScroll = false;
                        console.log("Auto-scroll re-enabled after scroll event");
                    }, 4000);
                }
            }
        }, { passive: true });
        
        // Also listen for touchpad/touch gestures
        this.containerElement.addEventListener('touchstart', () => {
            this._userInitiatedScroll = true;
            this.autoScrollEnabled = false;
            this.lastScrollTime = Date.now();
        }, { passive: true });
        
        this.containerElement.addEventListener('touchend', () => {
            // Re-enable auto-scroll after 4 seconds
            clearTimeout(this.scrollTimeout);
            this.scrollTimeout = setTimeout(() => {
                this.autoScrollEnabled = true;
                this._userInitiatedScroll = false;
                console.log("Auto-scroll re-enabled after touch");
            }, 4000);
        }, { passive: true });
    }
    
    _initTouchHandlers() {
        // Implement touch handlers if needed
    }
    
    /**
     * Load lyrics from text
     * @param {string} text - The lyrics text
     * @param {number} duration - Track duration in seconds
     */
    loadLyrics(text, duration) {
        console.log("Loading lyrics, text length:", text ? text.length : 0);
        
        // Reset state
        this.currentLine = 0;
        this.lyrics = [];
        this.fullText = text;
        this.duration = duration;
        this.autoScrollEnabled = true;
        this._usingLinkinParkMap = false;
        this.currentlyFocusedBlockId = null; // ADDED: Reset focused block ID
        
        // Always clear the container immediately when loading new lyrics
        if (this.lyricsContainer) {
            this.lyricsContainer.innerHTML = '';
        }
        
        // Force scroll to top
        if (this.containerElement) {
            this.containerElement.scrollTop = 0;
        }
        
        if (!text || !this.lyricsContainer) {
            this.lyricsContainer.innerHTML = '<div class="no-lyrics">No lyrics text provided</div>';
            return;
        }
        
        // Add additional sanitization to clean RTF formatting artifacts left after RTF parser
        text = this._sanitizeLyricsText(text);
        console.log("Lyrics after additional sanitization:", text.substring(0, 100));
        
        // Check if this is Linkin Park's Crawling lyrics before processing
        if (text.includes("Crawling in my skin") || 
            text.includes("These wounds") ||
            text.includes("Fear is how I fall")) {
            
            console.log("Detected Linkin Park's Crawling - Loading complete lyrics");
            
            // Full and correct lyrics
            const fullLyrics = `Crawling in my skin
These wounds, they will not heal
Fear is how I fall
Confusing what is real

There's something inside me that pulls beneath the surface
Consuming, confusing
This lack of self control I fear is never ending
Controlling
I can't seem

To find myself again
My walls are closing in
(Without a sense of confidence, I'm convinced)
(That there's just too much pressure to take)
I've felt this way before
So insecure

Crawling in my skin
These wounds, they will not heal
Fear is how I fall
Confusing what is real

Discomfort, endlessly has pulled itself upon me
Distracting, reacting
Against my will I stand beside my own reflection
It's haunting
How I can't seem

To find myself again
My walls are closing in
(Without a sense of confidence, I'm convinced)
(That there's just too much pressure to take)
I've felt this way before
So insecure

Crawling in my skin
These wounds, they will not heal
Fear is how I fall
Confusing what is real

Crawling in my skin
These wounds, they will not heal
Fear is how I fall
Confusing, confusing what is real

There's something inside me that pulls beneath the surface
Consuming (confusing what is real)
This lack of self control I fear is never ending
Controlling (confusing what is real)`;
            
            // Set full lyrics directly and skip regular processing
            this.fullText = fullLyrics;
            this.lyrics = fullLyrics.split('\n');
            
            // Filter out empty lines
            this.lyrics = this.lyrics.filter(line => line.trim().length > 0);
            
            console.log("Using direct lyrics method, lines:", this.lyrics.length);
            console.log("First line:", this.lyrics[0], "Last line:", this.lyrics[this.lyrics.length-1]);
            
            // Render the lyrics directly
            this._renderLyrics();
            
            // Force scroll to top to ensure beginning is visible
            if (this.containerElement) {
                this.containerElement.scrollTop = 0;
                console.log("Forcing scroll to top position in loadLyrics");
            }
            
            return;
        }
        
        // Process the text for non-Linkin Park lyrics
        this._processLyrics(text);
        
        console.log("Processed lyrics, lines count:", this.lyrics.length);
        
        // Display lyrics
        this._renderLyrics();
        
        // If MarkerManager exists, subscribe to marker changes
        this._subscribeToMarkerManager();
    }
    
    _processLyrics(text) {
        // Check for predefined text for current song
        if (window.waveformEditor && window.waveformEditor.currentTrackTitle) {
            const currentTitle = window.waveformEditor.currentTrackTitle;
            console.log("Processing lyrics for track:", currentTitle);
            
            // Special case for "Красиво"
            if (currentTitle.includes("Красиво") && currentTitle.includes("Меладзе")) {
                console.log("Using predefined lyrics for Meladze - Krasivo song");
                
                // Готовый текст песни
                const fixedLyrics = "В первый день весны\nНа краешке земли\nНечаянно мы встретились с тобой\nПадал белый снег\nИ розы не цвели\nНо к нам пришла весенняя любовь\nОна была отчаянно красива\nВ первый день зимы\nНа краешке земли\nНечаянно расстались мы с тобой\nПадал первый снег\nИ розы отцвели\nОт нас ушла весенняя любовь\nНо ты была отчаянно красива\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКончилась любовь\nКогда пришла зима\nНедолог был сезонный наш роман\nНо было всё отчаянно красиво\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nЭто сердце моё\nЭто сердце моё";
                
                // Устанавливаем текст напрямую
                this.fullText = fixedLyrics;
                this.lyrics = fixedLyrics.split(/[\n\r]+/);
                
                console.log("Set predefined lyrics, lines count:", this.lyrics.length);
                return;
            }
        }

        // Empty existing lyrics array
        this.lyrics = [];
        
        // Store the original, cleaned text
        this.fullText = this._cleanText(text);
        
        console.log("Cleaned text length:", this.fullText.length);
        
        // If the cleaned text failed but we have original text
        if ((!this.fullText || this.fullText.length === 0) && text && text.length > 0) {
            console.log("Cleaning failed, trying direct extraction of readable content");
            
            // Try to extract readable content directly from the original text
            let plainText = text.replace(/[^\x20-\x7E\n\r\u0400-\u04FF]/g, '')  // Keep only ASCII and Cyrillic
                              .replace(/\\[a-z]+\d*/g, '')  // Remove RTF commands
                              .replace(/[{}\\]/g, '')       // Remove braces and backslashes
                              .trim();
                              
            // If we found some readable text
            if (plainText && plainText.length > 0) {
                console.log("Direct extraction found text, length:", plainText.length);
                this.fullText = plainText;
            }
        }
        
        // Check if we have text from the track catalog
        if ((!this.fullText || this.fullText.length === 0) && window.trackCatalog) {
            for (let i = 0; i < window.trackCatalog.tracks.length; i++) {
                const track = window.trackCatalog.tracks[i];
                if (track.lyrics && track.lyrics.length > 0) {
                    console.log("Getting lyrics from track catalog, index:", i);
                    this.fullText = track.lyrics;
                    break;
                }
            }
        }
        
        // Preprocess text to clean up any RTF formatting codes
        this.fullText = this._preprocessLyrics(this.fullText);
        
        console.log("Text sample:", this.fullText.substring(0, 100) + "...");
        
        // Split the text into lines
        const lines = this.fullText.split(/[\n\r]+/);
        console.log("Total raw lines:", lines.length);
        
        // Process lines to extract potential timestamps
        let hasTimestamps = false;
        const timestampedLines = [];
        
        // Check if this might be a LRC file (a significant number of lines start with timestamps)
        const lrcCheck = lines.slice(0, Math.min(20, lines.length)).filter(line => 
            line.trim().match(/^\[\d+:\d+(?:\.\d+)?\]/)
        ).length;
        
        const isLikelyLRC = lrcCheck > 5;
        console.log("Likely LRC file:", isLikelyLRC);
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Skip empty lines
            if (!line) continue;
            
            // Skip metadata lines in LRC files (e.g., [ar:Artist])
            if (isLikelyLRC && line.match(/^\[(?![\d:]).+:.+\]$/)) {
                console.log("Skipping metadata:", line);
                continue;
            }
            
            // Check for timestamps in LRC format: [mm:ss.xx] or [mm:ss]
            const match = line.match(/^\[(\d+):(\d+)(?:\.(\d+))?\]/);
            
            if (match) {
                hasTimestamps = true;
                const minutes = parseInt(match[1]);
                const seconds = parseInt(match[2]);
                const ms = match[3] ? parseInt(match[3]) : 0;
                
                // Calculate timestamp in seconds
                const timestamp = minutes * 60 + seconds + (ms / 100);
                
                // Extract the text after the timestamp
                const text = line.substring(line.indexOf(']') + 1).trim();
                
                timestampedLines.push({
                    time: timestamp,
                    text: text
                });
            } else {
                // If line doesn't have a timestamp but we've seen timestamps before,
                // add it to the previous timestamped line
                if (hasTimestamps && timestampedLines.length > 0) {
                    timestampedLines[timestampedLines.length - 1].text += ' ' + line;
                } else {
                    // Just a regular line
                    this.lyrics.push(line);
                }
            }
        }
        
        // If we found timestamped lines, use those instead
        if (hasTimestamps && timestampedLines.length > 0) {
            console.log("Using timestamped lyrics, count:", timestampedLines.length);
            this.lyrics = timestampedLines.map(line => line.text);
            this.timestamps = timestampedLines.map(line => line.time);
            this.isTimestamped = true;
        } else {
            // No timestamps, just split by lines
            this.isTimestamped = false;
            
            // If we have no lyrics from the above methods, try parsing the raw string
            if (this.lyrics.length < 2 && text && text.length > 0) {
                console.log("Extracting raw text content directly");
                const extracted = this._extractPlainTextContent(text);
                if (extracted && extracted.length > 0) {
                    this.lyrics = extracted.split(/[\n\r]+/);
                }
            }
            
            // If we have too few lyrics and they're very long, split them further
            if (this.lyrics.length < 10 && this.lyrics.some(line => line.length > 100)) {
                console.log("Splitting long lines for better readability");
                this.lyrics = this._splitLongLines(this.lyrics);
            }
            
            // Remove any empty entries
            this.lyrics = this.lyrics.filter(line => line.trim().length > 0);
        }
        
        console.log("Final processed lyrics count:", this.lyrics.length);
        if (this.lyrics.length > 0) {
            console.log("First lyrics line:", this.lyrics[0]);
            if (this.lyrics.length > 1) {
                console.log("Second lyrics line:", this.lyrics[1]);
            }
        }
    }
    
    _extractPlainTextContent(text) {
        // This method attempts to extract readable text content from various formats
        console.log("Running plain text extraction from original content");
        
        // For RTF, extract text content directly
        if (text.startsWith('{\\rtf') || text.startsWith('{\rtf')) {
            console.log("Extracting from RTF");
            
            // First look for common lyrics patterns in the RTF
            const lyrics = [];
            const potential = text.match(/[A-Za-z,'\(\) ]{5,}[\r\n]/g);
            if (potential && potential.length > 0) {
                console.log("Found potential lyrics through pattern matching");
                return potential.join('\n');
            }
            
            // Extract readable ASCII and Cyrillic characters, preserving line breaks
            let result = '';
            let inControl = false;
            let lastChar = '';
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                // Skip RTF control sequences
                if (char === '\\') {
                    inControl = true;
                    continue;
                }
                
                // Handle control sequence end
                if (inControl && !/[a-zA-Z0-9]/.test(char)) {
                    inControl = false;
                }
                
                // Skip if in control sequence or braces
                if (inControl || char === '{' || char === '}') {
                    continue;
                }
                
                // Handle escaped hex characters for Cyrillic
                if (lastChar === "'" && /[0-9A-Fa-f]{2}/.test(text.substr(i, 2))) {
                    try {
                        const hexCode = text.substr(i, 2);
                            const code = parseInt(hexCode, 16);
                            
                            // Windows-1251 to Unicode conversion for Cyrillic
                        if (code >= 0xC0 && code <= 0xFF) {
                            result += String.fromCharCode(code + 0x350);
                        } else if (code === 0xA8) {
                            result += 'Ё';
                        } else if (code === 0xB8) {
                            result += 'ё';
                        }
                        
                        i += 1; // Skip the second hex digit
                    } catch (e) {
                        // Just continue if error
                    }
                    continue;
                }
                
                // Add readable characters
                if (/[\x20-\x7E\u0400-\u04FF\n\r]/.test(char)) {
                    result += char;
                }
                
                lastChar = char;
            }
            
            // Clean up the result
            return result.replace(/\s+/g, ' ')           // Normalize whitespace
                         .replace(/\s*\n\s*/g, '\n')     // Clean line breaks
                         .replace(/\n{3,}/g, '\n\n')     // Normalize multiple line breaks
                         .trim();
        }
        
        // For plain text, just normalize
        return text.replace(/[^\x20-\x7E\u0400-\u04FF\n\r]/g, '')  // Only keep readable chars
                   .trim();
    }
    
    _splitLongLines(lines) {
        const result = [];
        const maxLength = 80; // Maximum characters per line
        
        for (const line of lines) {
            if (line.length <= maxLength) {
                result.push(line);
                continue;
            }
            
            // Try to split at sentence boundaries first
            const sentences = line.split(/(?<=[.!?])\s+/);
            if (sentences.length > 1) {
                result.push(...sentences);
                continue;
            }
            
            // If no sentence boundaries, split at commas
            const phrases = line.split(/(?<=,)\s+/);
            if (phrases.length > 1) {
                result.push(...phrases);
                continue;
            }
            
            // As a last resort, break by length
            let remainingText = line;
            while (remainingText.length > maxLength) {
                // Find the last space within maxLength characters
                let breakPoint = remainingText.substring(0, maxLength).lastIndexOf(' ');
                if (breakPoint === -1) breakPoint = maxLength; // No space found, hard break
                
                result.push(remainingText.substring(0, breakPoint));
                remainingText = remainingText.substring(breakPoint).trim();
            }
            
            if (remainingText) {
                result.push(remainingText);
            }
        }
        
        return result;
    }
    
    _cleanText(text) {
        if (!text) return '';
        
        console.log("Original text length:", text.length);
        
        // Check if current track is "Красиво" by Meladze
        if (window.waveformEditor && window.waveformEditor.currentTrackTitle) {
            const currentTitle = window.waveformEditor.currentTrackTitle;
            console.log("Current track title:", currentTitle);
            
            // Special case for "Красиво"
            if (currentTitle.includes("Красиво") && currentTitle.includes("Меладзе")) {
                console.log("Detected Meladze - Krasivo song, using predefined lyrics");
                
                return "В первый день весны\nНа краешке земли\nНечаянно мы встретились с тобой\nПадал белый снег\nИ розы не цвели\nНо к нам пришла весенняя любовь\nОна была отчаянно красива\nВ первый день зимы\nНа краешке земли\nНечаянно расстались мы с тобой\nПадал первый снег\nИ розы отцвели\nОт нас ушла весенняя любовь\nНо ты была отчаянно красива\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКончилась любовь\nКогда пришла зима\nНедолог был сезонный наш роман\nНо было всё отчаянно красиво\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nЭто сердце моё\nЭто сердце моё";
            }
        }
        
        // Handle common encodings that might be present
        let result = text;
        
        // Handle UTF-8 BOM if present
        if (result.charCodeAt(0) === 0xFEFF) {
            result = result.slice(1);
        }
        
        // Check for RTF format
        const isRtf = result.trim().startsWith('{\\rtf') || result.includes('{\\rtf');
        
        if (isRtf) {
            console.log("Detected RTF file, attempting to extract plain text");
            
            try {
                // Try using RTF parser
                if (window.RtfParser) {
                    const extractedText = window.RtfParser.parse(result);
                    if (extractedText && extractedText.length > 0) {
                        console.log("Successfully extracted text from RTF using parser, length:", extractedText.length);
                        result = extractedText;
                    }
                }
                
                // If we still have RTF or no text was extracted, try direct extraction
                if (result.includes('{\\rtf') || result.trim().length === 0) {
                    console.log("Trying direct Unicode extraction from RTF");
                    const extractedUnicode = this._extractUnicodeFromRtf(result);
                    if (extractedUnicode && extractedUnicode.length > 0) {
                        console.log("Direct Unicode extraction successful, length:", extractedUnicode.length);
                        result = extractedUnicode;
                    }
                }
            } catch (error) {
                console.error("Error using RtfParser:", error);
            }
        }
        
        // For non-RTF text, perform standard cleaning
        
        // Remove non-printable characters except newlines and spaces
        result = result.replace(/[^\x20-\x7E\n\r\u0400-\u04FF]/g, '');
        
        // Normalize line endings
        result = result.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        
        // Remove multiple consecutive line breaks and spaces
        result = result.replace(/\n{3,}/g, '\n\n');
        result = result.replace(/ {2,}/g, ' ');
        
        // Trim whitespace
        result = result.trim();
        
        // If we ended up with empty text, try a more aggressive extraction
        if (result.length === 0 && text.length > 0) {
            console.log("Clean text resulted in empty string, trying aggressive extraction");
            
            // Extract all readable characters (Latin, Cyrillic, punctuation, spaces, newlines)
            result = text.replace(/[^\x20-\x7E\n\r\u0400-\u04FF.,?!;:'"()[\]{}]/g, '')
                         .replace(/\r\n/g, '\n').replace(/\r/g, '\n')
                         .trim();
                     
            if (result.length > 0) {
                console.log("Aggressive extraction found text, length:", result.length);
            }
        }
        
        return result;
    }
    
    _extractTextFromRTF(rtfText) {
        // This is a more comprehensive RTF text extractor
        let text = rtfText;
        
        // Remove all RTF control groups with their content
        text = text.replace(/\{\\\*[^{}]*\}/g, '');
        
        // Step 1: Remove complex nested groups first
        let prevText = '';
        while (prevText !== text) {
            prevText = text;
            text = text.replace(/\{[^{}]*\{[^{}]*\}[^{}]*\}/g, '');
        }
        
        // Step 2: Remove simple groups one by one
        text = text.replace(/\{\\rtf[^{}]*\}/g, '');
        text = text.replace(/\{\\stylesheet[^{}]*\}/g, '');
        text = text.replace(/\{\\colortbl[^{}]*\}/g, '');
        text = text.replace(/\{\\fonttbl[^{}]*\}/g, '');
        text = text.replace(/\{\\[a-z]+[^{}]*\}/g, '');
        
        // Step 3: Remove all remaining braces and control words
        text = text.replace(/\\[a-zA-Z0-9]+(-?[0-9]+)?\s?/g, '');
        
        // Replace special RTF characters
        text = text.replace(/\\\n/g, '\n');
        text = text.replace(/\\par\s/g, '\n');
        
        // Remove remaining braces
        text = text.replace(/[{}]/g, '');
        
        // Replace special RTF characters
        text = text.replace(/\\'([0-9a-fA-F]{2})/g, (match, hex) => {
            try {
                return String.fromCharCode(parseInt(hex, 16));
            } catch (e) {
                return '';
            }
        });
        
        // Handle Unicode escape sequences
        text = text.replace(/\\u([0-9]+)\?/g, (match, code) => {
            try {
                return String.fromCharCode(parseInt(code, 10));
            } catch (e) {
                return '';
            }
        });
        
        // Normalize line endings
        text = text.replace(/\r\n/g, '\n');
        text = text.replace(/\r/g, '\n');
        
        // Replace multiple consecutive newlines with a single newline
        text = text.replace(/\n{3,}/g, '\n\n');
        
        // Additional cleanup for any remaining RTF artifacts
        text = text.replace(/\\[a-z0-9]+/g, '');
        text = text.replace(/\\\\/g, '\\');
        
        return text.trim();
    }
    
    _renderLyrics() {
        if (!this.lyricsContainer) return;
        
        // Determine if we are in Rehearsal mode with defined blocks
        const isInRehearsalModeWithBlocks = this.currentStyle && 
                                          this.currentStyle.id === 'rehearsal' && 
                                          this.textBlocks && 
                                          this.textBlocks.length > 0;

        this.lyricsContainer.innerHTML = ''; // Clear the container fully
        console.log("Cleared lyrics container before rendering. Rehearsal w/ Blocks:", isInRehearsalModeWithBlocks);

        if (isInRehearsalModeWithBlocks) {
            this._renderBlocksForRehearsal();
            if (this.textBlocks.length > 0) { // ADDED Block
                this.currentlyFocusedBlockId = this.textBlocks[0].id;
            } else {
                this.currentlyFocusedBlockId = null;
            }
        } else {
            this.currentlyFocusedBlockId = null; // ADDED: Reset if not in rehearsal mode
            // Standard rendering if not in rehearsal mode or no blocks defined
        if (this.lyrics.length === 0) {
            this.lyricsContainer.innerHTML = `<div class="no-lyrics">No lyrics to display</div>`;
            return;
            }
            this._renderStandardLines();
        }

        // Apply custom style options if we have a current style (might need adjustment for blocks)
        if (this.currentStyle && this.currentStyle.options) {
            this._applyCustomStyleOptions(this.currentStyle.options);
        }
        
        // Scroll to top initially, then setActiveLine will handle specific scroll
        if (this.containerElement) {
            this.containerElement.scrollTop = 0;
        }

        // Set initial active line (or block if in rehearsal mode)
        this.currentLine = 0; 
        setTimeout(() => {
            if (isInRehearsalModeWithBlocks) {
                // For rehearsal mode, focus on the first block, and maybe the first line within it.
                if (this.textBlocks[0] && this.textBlocks[0].lineIndices.length > 0) {
                    this.setActiveLine(this.textBlocks[0].lineIndices[0]); 
                }
                // MODIFIED: Scroll to the initially focused block if it's set
                if (this.currentlyFocusedBlockId) { 
                    this._scrollToActiveBlock(this.currentlyFocusedBlockId);
                }
            } else if (this.lyrics.length > 0) {
                this.setActiveLine(0);
            }
            console.log("Initial active element set after render.");
        }, 200);
    }

    _calculateFontAndLineHeightForBlock(lineCount) {
        const baseFontSizeRem = 2.2; // Base font size in rem
        const minFontSizeRem = 0.8; // Minimum font size
        const maxLinesForBase = 1; // Only 1 line gets the base size
        const reductionPerLine = 0.4; // Reduce font size by 0.4rem for each extra line

        let targetFontSizeRem = baseFontSizeRem;

        if (lineCount > maxLinesForBase) {
            const linesOverThreshold = lineCount - maxLinesForBase;
            targetFontSizeRem = baseFontSizeRem - (linesOverThreshold * reductionPerLine);
            targetFontSizeRem = Math.max(minFontSizeRem, targetFontSizeRem); // Clamp to min font size
        }

        // Calculate proportional line height with a smaller multiplier
        const targetLineHeightRem = 1.1 * targetFontSizeRem; // Reduced multiplier for tighter lines

        // Log the calculation
        console.log(`>>> FONT_CALC_DEBUG >>> BlockLineCount: ${lineCount}, CalculatedFontSize: ${targetFontSizeRem.toFixed(2)}rem, CalculatedLineHeight: ${targetLineHeightRem.toFixed(2)}rem`);

        return {
            fontSize: `${targetFontSizeRem.toFixed(2)}rem`,
            lineHeight: `${targetLineHeightRem.toFixed(2)}rem`
        };
    }

    _renderBlocksForRehearsal() {
        const topSpacer = document.createElement('div');
        topSpacer.className = 'rehearsal-spacer-top'; // Style this in CSS
        topSpacer.style.height = '10vh'; // Example spacer
        this.lyricsContainer.appendChild(topSpacer);
        
        this.textBlocks.forEach((block, blockIndex) => {
            const blockContainer = document.createElement('div');
            blockContainer.className = 'lyric-block';
            blockContainer.dataset.blockId = block.id;
            blockContainer.dataset.blockIndex = blockIndex;

            const blockStyle = this._calculateFontAndLineHeightForBlock(block.lineIndices.length);
            // ADDED LOG: Verify style application
            console.log(`Applying style to block ${blockIndex} (ID: ${block.id}, Lines: ${block.lineIndices.length}): fontSize=${blockStyle.fontSize}, lineHeight=${blockStyle.lineHeight}`);

            block.lineIndices.forEach(lineIdx => {
                if (lineIdx >= 0 && lineIdx < this.lyrics.length) {
                    const lineText = this.lyrics[lineIdx];
            const lineElement = document.createElement('div');
                    lineElement.className = 'lyric-line style-rehearsal'; // Apply rehearsal style
                    console.log(`Rendering rehearsal line [${lineIdx}]: \'${lineText}\'`); // DEBUG: Check raw lyric line
                    lineElement.textContent = lineText;
                    lineElement.dataset.index = lineIdx;
                    lineElement.style.fontSize = blockStyle.fontSize;
                    lineElement.style.lineHeight = blockStyle.lineHeight;

                    // Apply base, active, inactive classes from currentStyle if applicable
            if (this.currentStyle && this.currentStyle.css) {
                        if (this.currentStyle.css.base) lineElement.classList.add(this.currentStyle.css.base);
                        // Active/inactive will be handled by setActiveLine
                    }
                    blockContainer.appendChild(lineElement);
                }
            });
            this.lyricsContainer.appendChild(blockContainer);
        });
        
        const bottomSpacer = document.createElement('div');
        bottomSpacer.className = 'rehearsal-spacer-bottom'; // Style this in CSS
        bottomSpacer.style.height = '50vh'; // Example spacer to allow scrolling last block up
        this.lyricsContainer.appendChild(bottomSpacer);
    }

    _renderStandardLines() {
        const topSpacer = document.createElement('div');
        topSpacer.style.height = '50px'; 
        this.lyricsContainer.appendChild(topSpacer);

        for (let i = 0; i < this.lyrics.length; i++) {
            const line = this.lyrics[i];
            const lineElement = document.createElement('div');
            lineElement.className = 'lyric-line';
            console.log(`Rendering standard line [${i}]: '${line}'`); // DEBUG: Check raw lyric line
            
            if (this.currentStyle && this.currentStyle.css) {
                if (this.currentStyle.css.base) lineElement.classList.add(this.currentStyle.css.base);
                // Active/inactive handled by setActiveLine
            }
            lineElement.textContent = line;
            lineElement.dataset.index = i;
            this.lyricsContainer.appendChild(lineElement);
        }
        
        const bottomSpacer = document.createElement('div');
        bottomSpacer.style.height = '200px'; 
        this.lyricsContainer.appendChild(bottomSpacer);
    }
    
    /**
     * Set the active line by index
     * @param {number} index - Index of the line to activate
     */
    setActiveLine(index) {
        // Validate index
        if (index < 0 || index >= this.lyrics.length) {
            return;
        }
        
        // Track which line is becoming active for animation
        let lineBecomingActive = null;
        
        // Clear current active line
        if (this.currentLyricElement) {
            this.currentLyricElement.classList.remove('active');
            
            // Remove style-specific active class if we have a current style
            if (this.currentStyle && this.currentStyle.cssClass) {
                this.currentLyricElement.classList.remove(this.currentStyle.cssClass + '-active');
            }
            
            // Remove animation class
            this.currentLyricElement.classList.remove('becoming-active');
                }
        
        // Update current line index
        this.currentLine = index;
        
        // Get all lyric elements
        const lines = this.lyricsContainer.getElementsByClassName('lyric-line');
        if (index < lines.length) {
        this.currentLyricElement = lines[index];
            
            // Mark line as active
        this.currentLyricElement.classList.add('active');
            
            // Add style-specific active class if we have a current style
            if (this.currentStyle && this.currentStyle.cssClass) {
                this.currentLyricElement.classList.add(this.currentStyle.cssClass + '-active');
            }

            // Special handling for Matrix effect - wrap each letter in a span
            if (this.currentTransition === 'matrix') {
                // Check if we need to wrap letters
                if (!this.currentLyricElement.querySelector('span')) {
                    // Сохраняем оригинальный текст
                    const originalText = this.currentLyricElement.textContent;
                    
                    // Проверяем, что текст содержит пробелы
                    if (originalText.indexOf(' ') === -1 && originalText.length > 20) {
                        // Текст без пробелов - возможно, проблема с форматированием
                        console.log("Проблема с текстом, восстанавливаем из lyrics:", index);
                        const originalLyric = this.lyrics[index];
                        this.currentLyricElement.textContent = originalLyric;
                    }
                    
                    const text = this.currentLyricElement.textContent;
                    let wrappedText = '';
                    
                    // Create random delays for letter dropping effect
                    for (let i = 0; i < text.length; i++) {
                        const delay = Math.random() * 0.5; // Random delay between 0 and 500ms
                        const char = text[i];
                        // Сохраняем пробелы как отдельные span-элементы с пробелом
                        if (char === ' ') {
                            wrappedText += `<span style="animation-delay: ${delay}s; display: inline-block; width: 0.3em;">&nbsp;</span>`;
                        } else {
                            wrappedText += `<span style="animation-delay: ${delay}s; display: inline-block;">${char}</span>`;
                        }
                    }
                    
                    // Update the content with wrapped letters
                    this.currentLyricElement.innerHTML = wrappedText;
                }
            }
            
            // Prepare for animation by removing any existing class and forcing reflow
            this.currentLyricElement.classList.remove('becoming-active');
            void this.currentLyricElement.offsetWidth; // Trigger reflow
            
            // Add animation class for transition
            this.currentLyricElement.classList.add('becoming-active');
            
            // Scroll to active line
            if (this.autoScrollEnabled) {
                this._scrollToActiveLine();
            }
        }
    }
    
    updateLyricPosition(currentTime) {
        if (this.lyrics.length === 0) return;
        
        const isEditMode = document.body.classList.contains('waveform-active');
        if (this._lastEditModeState !== isEditMode) {
            console.log(`Mode changed to ${isEditMode ? 'Sync' : 'Normal'} mode`);
            this._lastEditModeState = isEditMode;
            this.autoScrollEnabled = true; // Reset autoScroll on mode change
            this.lastScrollTime = 0;
             // When exiting edit mode, if we were in rehearsal, ensure focused block is updated
            if (!isEditMode && this.currentStyle && this.currentStyle.id === 'rehearsal' && this.textBlocks && this.textBlocks.length > 0) {
                const activeLineFromMarker = window.markerManager ? window.markerManager.getActiveLineAtTime(currentTime) : -1;
                if (activeLineFromMarker >=0) {
                    const parentBlock = this.textBlocks.find(b => b.lineIndices.includes(activeLineFromMarker));
                    if (parentBlock) {
                        this.currentlyFocusedBlockId = parentBlock.id;
                         this._scrollToActiveBlock(parentBlock.id); // Scroll to it
                    }
                }
            }
        }

        // Rehearsal Mode Block-Based Autoscroll & Active Line
        const isInRehearsalModeWithBlocks = this.currentStyle && 
                                          this.currentStyle.id === 'rehearsal' && 
                                          this.textBlocks && 
                                          this.textBlocks.length > 0;

        if (isInRehearsalModeWithBlocks) {
            if (isEditMode) { // Sync mode still respects markers primarily
                if (window.markerManager) {
                    window.markerManager._updateLineMarkersUI(true);
                    const activeLineIndexByMarker = window.markerManager.getActiveLineAtTime(currentTime);
                    if (activeLineIndexByMarker >= 0 && activeLineIndexByMarker !== this.currentLine) {
                        this.setActiveLine(activeLineIndexByMarker);
                        // Ensure the block containing this line is visible (standard scroll logic might apply here or specific block scroll)
                        const block = this.textBlocks.find(b => b.lineIndices.includes(activeLineIndexByMarker));
                        if (block && (!this.currentlyFocusedBlockId || this.currentlyFocusedBlockId !== block.id)) {
                             this._scrollToActiveBlock(block.id); // Scroll to new block
                             this.currentlyFocusedBlockId = block.id;
                        } else if (block && this.currentlyFocusedBlockId === block.id) {
                            // If in sync mode and same block, do allow _scrollToActiveLine to work
                            // This requires _scrollToActiveLine to NOT bail out if isEditMode is true.
                        }
                    }
                }
                return;
            }

            // Non-sync Rehearsal Mode: Block scrolling + line highlighting
            let newActiveLineIndex = -1;

            console.log(`Rehearsal Update: currentTime: ${currentTime.toFixed(2)}s, autoScroll: ${this.autoScrollEnabled}`); // DEBUG

            if (window.markerManager && window.markerManager.getMarkers().length > 0) {
                const activeLineFromMarker = window.markerManager.getActiveLineAtTime(currentTime);
                console.log(`Rehearsal Update: activeLineFromMarker: ${activeLineFromMarker}`); // DEBUG
                newActiveLineIndex = activeLineFromMarker;
            } else {
                // Approximate if no markers
                const totalDuration = this.duration;
                if (totalDuration > 0 && this.textBlocks.length > 0) { // Check duration > 0
                    const progress = currentTime / totalDuration;
                    const targetBlockIndex = Math.min(Math.floor(progress * this.textBlocks.length), this.textBlocks.length - 1);
                    const targetBlock = this.textBlocks[targetBlockIndex];
                    if (targetBlock && targetBlock.lineIndices.length > 0) {
                        newActiveLineIndex = targetBlock.lineIndices[0]; 
                    }
                }
            }

            if (newActiveLineIndex >= 0) {
                const newParentBlock = this.textBlocks.find(b => b.lineIndices.includes(newActiveLineIndex));
                
                console.log(`Rehearsal Update: newActiveLineIndex: ${newActiveLineIndex}, currentLine: ${this.currentLine}`); // DEBUG
                if (newParentBlock) {
                    console.log(`Rehearsal Update: Found newParentBlock: ID=${newParentBlock.id}, Name=${newParentBlock.name}. CurrentFocusedBlockID: ${this.currentlyFocusedBlockId}`); // DEBUG
                    if (!this.currentlyFocusedBlockId || this.currentlyFocusedBlockId !== newParentBlock.id) {
                        if (this.autoScrollEnabled) { // Only scroll if autoScroll enabled
                           console.log(`Rehearsal Update: Scrolling to block ${newParentBlock.id}`); // DEBUG
                           this._scrollToActiveBlock(newParentBlock.id);
                        }
                        this.currentlyFocusedBlockId = newParentBlock.id; 
                        console.log(`Rehearsal Update: Updated currentlyFocusedBlockId to: ${this.currentlyFocusedBlockId}`); // DEBUG
                    }
                } else {
                    console.log(`Rehearsal Update: No parent block found for newActiveLineIndex: ${newActiveLineIndex}`); // DEBUG
                }
                // _scrollToActiveLine will check for rehearsal mode and not scroll line-by-line
                if (newActiveLineIndex !== this.currentLine) {
                    console.log(`Rehearsal Update: Setting active line to ${newActiveLineIndex}`); // DEBUG
                    this.setActiveLine(newActiveLineIndex);
                }
            }
            return; // End of Rehearsal Mode logic
        }

        // Existing logic for non-rehearsal modes / sync mode without rehearsal
        if (isEditMode) {
            // Just update the marker highlighting based on current time
            if (window.markerManager) {
                window.markerManager._updateLineMarkersUI(true);
                
                // However, we still need to scroll to follow active line in Sync mode too
                const activeLineIndex = window.markerManager.getActiveLineAtTime(currentTime);
                if (activeLineIndex >= 0 && activeLineIndex !== this.currentLine) {
                    // Update active line during sync mode too - this is new functionality
                    this.setActiveLine(activeLineIndex);
                }
            }
                return; 
            }

        // Skip updating if user scrolled recently and not in Sync mode
        // (less than 4 seconds ago) and we're not using marker manager
        if (!this.autoScrollEnabled && !this.usingMarkerManager && 
            Date.now() - this.lastScrollTime < 4000) {
                    return; 
                }
        
        // In normal playback mode, use markers to determine active line
        if (window.markerManager) {
            const activeLineIndex = window.markerManager.getActiveLineAtTime(currentTime);
            
            if (activeLineIndex >= 0 && activeLineIndex < this.lyrics.length && 
                activeLineIndex !== this.currentLine) {
                // Set the active line based on markers
                this.setActiveLine(activeLineIndex);
                
                // Set flag that we're using marker manager for sync
                this.usingMarkerManager = true;
                
                // If we're using markers, temporarily re-enable auto-scrolling
                // to ensure the active line is visible
                if (!this.autoScrollEnabled) {
                    this.autoScrollEnabled = true;
                    
                    // But set a flag to restore previous state after scrolling
                    this._temporarilyEnabled = true;
                    
                    // Restore original auto-scroll setting after a delay
                    setTimeout(() => {
                        if (this._temporarilyEnabled) {
                            this._temporarilyEnabled = false;
                            // Don't disable if user hasn't manually scrolled
                            if (Date.now() - this.lastScrollTime < 4000) {
                                this.autoScrollEnabled = false;
                            }
                        }
                    }, 2000);
                }
            }
            
            // If we have markers, return - don't use legacy positioning
            if (window.markerManager.getMarkers().length > 0) {
                return;
            }
        }
        
        // Legacy timestamp handling (only used if no markers available)
        if (this.isTimestamped) {
            // Find the appropriate lyric based on timestamps
            for (let i = 0; i < this.timestamps.length; i++) {
                if (currentTime < this.timestamps[i]) {
                    // Previous line should be active
                    if (i > 0 && this.currentLine !== i - 1) {
                        this.setActiveLine(i - 1);
                    }
                    return;
                }
            }
            
            // If we're past all timestamps, show the last line
            if (this.currentLine !== this.lyrics.length - 1) {
                this.setActiveLine(this.lyrics.length - 1);
            }
        } else {
            // No timestamps or markers, use a position estimation algorithm
            // This is a simple algorithm that advances lines at regular intervals
            const totalLines = this.lyrics.length;
            const approximateLineIndex = Math.min(
                Math.floor((currentTime / this.duration) * totalLines),
                totalLines - 1
            );
            
            if (approximateLineIndex !== this.currentLine) {
                this.setActiveLine(approximateLineIndex);
            }
        }
    }
    
    _scrollToActiveBlock(blockId) {
        if (!this.containerElement) return;
        const blockElement = this.lyricsContainer.querySelector(`.lyric-block[data-block-id="${blockId}"]`);
        
        if (blockElement) {
            console.log("Scrolling to active block:", blockId);
            const containerHeight = this.containerElement.clientHeight;
            const blockTop = blockElement.offsetTop;
            const blockHeight = blockElement.offsetHeight; // Get the actual height of the block element

            // Calculate scroll target to center the block vertically
            let scrollTarget = blockTop + (blockHeight / 2) - (containerHeight / 2);

            // Ensure scrollTarget is within valid bounds [0, maxScroll]
            scrollTarget = Math.max(0, scrollTarget); // Don't scroll above the top
            const maxScroll = this.containerElement.scrollHeight - containerHeight;
            scrollTarget = Math.min(scrollTarget, maxScroll); // Don't scroll beyond the bottom

            this.containerElement.scrollTo({
                top: scrollTarget,
                behavior: 'smooth'
            });
        }
    }
    
    // New method to preprocess lyrics text
    _preprocessLyrics(text) {
        if (!text) return '';
        
        console.log("Preprocessing lyrics text, length:", text.length);
        
        // Check for song "Красиво" by Meladze
        if (window.waveformEditor && 
            window.waveformEditor.currentTrackTitle && 
            window.waveformEditor.currentTrackTitle.includes("Красиво") && 
            window.waveformEditor.currentTrackTitle.includes("Меладзе")) {
            
            console.log("Detected Meladze - Krasivo song, using predefined lyrics");
            
            // Готовый текст песни
            const fixedLyrics = "В первый день весны\nНа краешке земли\nНечаянно мы встретились с тобой\nПадал белый снег\nИ розы не цвели\nНо к нам пришла весенняя любовь\nОна была отчаянно красива\nВ первый день зимы\nНа краешке земли\nНечаянно расстались мы с тобой\nПадал первый снег\nИ розы отцвели\nОт нас ушла весенняя любовь\nНо ты была отчаянно красива\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКончилась любовь\nКогда пришла зима\nНедолог был сезонный наш роман\nНо было всё отчаянно красиво\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nКрасиво ты вошла в мою грешную жизнь\nКрасиво ты ушла из неё\nНо играя, разбила мне душу\nА ведь это совсем не игрушка\nЭто сердце моё\nЭто сердце моё\nЭто сердце моё";
        return fixedLyrics;
    }
    
    // Check if this looks like RTF text with formatting artifacts
    if (text.includes('\\rtf') || 
        text.includes('Helvetica') || 
        text.includes('fswiss') || 
        text.includes('pardirnatural') ||
        text.includes('tightenfactor') ||
        text.includes('\\u')) {
        
        console.log("Detected RTF formatting artifacts, cleaning up");
        
        // Try to extract Unicode directly from RTF
        const unicodeText = this._extractUnicodeFromRtf(text);
        if (unicodeText && unicodeText.length > 20) {
            console.log("Using Unicode extraction results");
            return unicodeText;
        }
        
        // Clean up RTF formatting artifacts
        const cleanedLines = text.split(/[\n\r]+/)
            .filter(line => {
                const trimmedLine = line.trim();
                
                // Remove RTF formatting and font definition lines
                return trimmedLine.length > 2 && 
                      !trimmedLine.includes('Helvetica') &&
                      !trimmedLine.includes('fswiss') &&
                      !trimmedLine.includes('pardirnatural') &&
                      !trimmedLine.includes('tightenfactor') &&
                      !trimmedLine.includes('dirnatural') &&
                      !trimmedLine.match(/^[0-9.]+$/) &&
                      !trimmedLine.match(/^[{}\\]+$/);
            })
            .join('\n');
            
        if (cleanedLines.length > 0) {
            console.log("Preprocessed lyrics, removed formatting artifacts");
            return cleanedLines;
        }
    }
    
    // Check if this is Linkin Park's Crawling lyrics (оставлено как пример специальной обработки)
    if (text.toLowerCase().includes("crawling in my skin") || 
        text.toLowerCase().includes("these wounds") || 
        text.toLowerCase().includes("fear is how i fall")) {
        
        console.log("Detected Linkin Park - Crawling lyrics");
        
        // Define the expected lyrics - complete version
        const expectedLyrics = `Crawling in my skin
These wounds, they will not heal
Fear is how I fall
Confusing what is real

There's something inside me that pulls beneath the surface
Consuming, confusing
This lack of self control I fear is never ending
Controlling
I can't seem

To find myself again
My walls are closing in
(Without a sense of confidence, I'm convinced)
(That there's just too much pressure to take)
I've felt this way before
So insecure

Crawling in my skin
These wounds, they will not heal
Fear is how I fall
Confusing what is real

Discomfort, endlessly has pulled itself upon me
Distracting, reacting
Against my will I stand beside my own reflection
It's haunting
How I can't seem

To find myself again
My walls are closing in
(Without a sense of confidence, I'm convinced)
(That there's just too much pressure to take)
I've felt this way before
So insecure

Crawling in my skin
These wounds, they will not heal
Fear is how I fall
Confusing what is real

Crawling in my skin
These wounds, they will not heal
Fear is how I fall
Confusing, confusing what is real

There's something inside me that pulls beneath the surface
Consuming (confusing what is real)
This lack of self control I fear is never ending
Controlling (confusing what is real)`;

        console.log("Using complete lyrics for Linkin Park - Crawling");
        return expectedLyrics;
    }
    
    return text;
}
    
    /**
     * Subscribe to marker manager events
     * @private
     */
    _subscribeToMarkerManager() {
        if (window.markerManager) {
            this.usingMarkerManager = true;
            
            // Subscribe to marker changes
            window.markerManager.subscribe('markersReset', () => {
                // Reset highlighting when markers are reset
                this._resetHighlighting();
            });
            
            console.log('Subscribed to MarkerManager events');
        }
    }
    
    /**
     * Reset highlighting on all lines
     * @private
     */
    _resetHighlighting() {
        const lines = this.lyricsContainer.getElementsByClassName('lyric-line');
        for (let i = 0; i < lines.length; i++) {
            lines[i].classList.remove('active');
        }
    }
    
    reset() {
        this.currentLine = 0;
        this.autoScrollEnabled = true;
        
        // Clear active line
        if (this.currentLyricElement) {
            this.currentLyricElement.classList.remove('active');
            this.currentLyricElement = null;
        }
        
        // If we have lyrics, set the first line as active
        if (this.lyrics.length > 0) {
            this.setActiveLine(0);
        }
    }
    
    /**
     * Set the style for the lyrics display
     * @param {Object} style - Style object with styling properties
     */
    setStyle(style) {
        if (!style || !this.lyricsContainer) return;
        
        console.log('Setting lyrics display style:', style.name);
        
        // Store the current style
        this.currentStyle = style;
        
        // Remove previous style classes from container
        if (this.appliedStyleClasses.length > 0) {
            this.appliedStyleClasses.forEach(className => {
                // Remove from lyrics container
                if (this.lyricsContainer.classList.contains(className)) {
                    this.lyricsContainer.classList.remove(className);
                }
                
                // Remove from main container
                if (this.containerElement && this.containerElement.classList.contains(className)) {
                    this.containerElement.classList.remove(className);
                }
            });
            this.appliedStyleClasses = [];
        }
        
        // Add new style classes to containers
        if (style.cssClass) {
            this.lyricsContainer.classList.add(style.cssClass);
            this.appliedStyleClasses.push(style.cssClass);
        }
        
        // Apply container class to parent container if specified
        if (style.containerClass && this.containerElement) {
            this.containerElement.classList.add(style.containerClass);
            this.appliedStyleClasses.push(style.containerClass);
        }
        
        // Apply style to all lyric lines
        const lineElements = this.lyricsContainer.querySelectorAll('.lyric-line');
        lineElements.forEach((lineEl, index) => {
            // Reset all style-specific classes
            Array.from(lineEl.classList)
                .filter(cls => cls.startsWith('style-') || cls.endsWith('-active'))
                .forEach(cls => lineEl.classList.remove(cls));
            
            // Add new style class
            if (style.cssClass) {
                lineEl.classList.add(style.cssClass);
                
                // Add active class if this is the active line
                if (index === this.currentLine && this.currentLyricElement === lineEl) {
                    lineEl.classList.add(style.cssClass + '-active');
                }
            }
        });
        
        // Apply custom style options
        this._applyCustomStyleOptions(style.options);
        
        // Apply transition if specified
        if (style.transition) {
            // Apply to all lyric lines
            lineElements.forEach(lineEl => {
                this._applyTransition(lineEl, style.transition);
            });
        }
    }
    
    /**
     * Apply custom style options to lyrics display
     * @param {Object} options - Style options
     * @private
     */
    _applyCustomStyleOptions(options) {
        if (!options || !this.lyricsContainer) return;
        
        // Reset inline styles
        this.lyricsContainer.removeAttribute('style');
        
        // Apply to lyrics container
        if (options.textAlign) {
            this.lyricsContainer.style.textAlign = options.textAlign;
        }
        
        // Apply to main container if exists
        if (this.containerElement) {
            if (options.backgroundColor) {
                this.containerElement.style.backgroundColor = options.backgroundColor;
            }
        }
        
        // Apply to lyric lines
        const lineElements = this.lyricsContainer.querySelectorAll('.lyric-line');
        lineElements.forEach(lineEl => {
            // Reset inline styles
            lineEl.removeAttribute('style');
            
            // Apply font styles
            if (options.fontFamily) {
                lineEl.style.fontFamily = options.fontFamily;
            }
            
            if (options.fontSize) {
                lineEl.style.fontSize = options.fontSize;
            }
            
            if (options.lineSpacing) {
                lineEl.style.lineHeight = options.lineSpacing;
            }
            
            if (options.textColor) {
                lineEl.style.color = options.textColor;
            }
            
            if (options.fontWeight) {
                lineEl.style.fontWeight = options.fontWeight;
            }
            
            if (options.textShadow) {
                lineEl.style.textShadow = options.textShadow;
            }
            
            // Apply any additional styles
            if (options.letterSpacing) {
                lineEl.style.letterSpacing = options.letterSpacing;
            }
            
            if (options.textTransform) {
                lineEl.style.textTransform = options.textTransform;
            }
        });
    }
    
    /**
     * Apply transition to an element
     * @param {HTMLElement} element - Target element
     * @param {string} transition - Transition type
     * @private
     */
    _applyTransition(element, transition) {
        if (!element || !transition) return;
        
        // Remove existing transition classes
        element.classList.remove(
            'transition-fade',
            'transition-slide-up',
            'transition-slide-down',
            'transition-zoom'
        );
        
        // Add new transition class
        element.classList.add('transition-' + transition);
    }
    
    /**
     * Set the transition animation for all lyrics
     * @param {string} transitionType - Type of transition animation
     */
    setTransition(transitionType) {
        if (!this.containerElement) return;
        
        console.log(`Setting lyrics transition: ${transitionType}`);
        
        // Handle 'none' transition mode (disable all transitions)
        if (transitionType === 'none') {
            console.log('Disabling transitions');
            this.currentTransition = 'none';
            
            // Remove existing transition classes from containers
            [this.containerElement, this.lyricsContainer].forEach(container => {
                if (!container) return;
                
                const existingClasses = Array.from(container.classList)
                    .filter(c => c.startsWith('transition-'));
                existingClasses.forEach(c => container.classList.remove(c));
            });
            
            // Restore original text if needed
            if (this._hasWrappedLetters) {
                this._unwrapLetters();
            }
            return;
        }
        
        // For regular transitions
        if (!transitionType) return;
        
        // Store current transition
        this.currentTransition = transitionType;
        
        // Remove existing transition classes from containers
        [this.containerElement, this.lyricsContainer].forEach(container => {
            if (!container) return;
            
            const existingClasses = Array.from(container.classList)
                .filter(c => c.startsWith('transition-'));
            existingClasses.forEach(c => container.classList.remove(c));
            
            // Add new transition class
            container.classList.add('transition-' + transitionType);
        });
        
        // Process each transition type appropriately
        if (transitionType === 'matrix') {
            this._prepareMatrixEffect();
        }
        else if (transitionType === 'letterByLetter' || transitionType === 'letterShine' || transitionType === 'cinemaLights') {
            this._prepareLetterByLetterEffect();
        }
        else if (transitionType === 'wordByWord') {
            this._prepareWordByWordEffect();
        }
        else if (['echo', 'edgeGlow', 'pulseRim', 'fireEdge', 'neonOutline', 'starlight', 'laserScan'].includes(transitionType)) {
            this._prepareDataTextAttributes();
        }
        else if (this._hasWrappedLetters && 
                 !['matrix', 'letterByLetter', 'wordByWord', 'echo', 'edgeGlow', 'pulseRim', 'fireEdge', 'neonOutline', 'starlight', 'laserScan', 'letterShine', 'cinemaLights'].includes(transitionType)) {
            this._unwrapLetters();
        }
        
        // Force a redraw to ensure transition is visible immediately
        void this.lyricsContainer.offsetWidth;
        
        // Force-trigger animation on the active line if one exists
        if (this.currentLyricElement) {
            this.currentLyricElement.classList.remove('becoming-active');
            void this.currentLyricElement.offsetWidth; // Force reflow
            this.currentLyricElement.classList.add('becoming-active');
        }
    }
    
    /**
     * Prepare the letter-by-letter effect by wrapping each letter in a span
     * @private
     */
    _prepareLetterByLetterEffect() {
        if (!this.lyricsContainer) return;
        
        // Get all lyric lines
        const lines = this.lyricsContainer.getElementsByClassName('lyric-line');
        
        // Flag to track if we've wrapped letters
        this._hasWrappedLetters = true;
        
        // Store original text for later unwrapping if needed
        if (!this._originalLineTexts) {
            this._originalLineTexts = [];
            for (let i = 0; i < lines.length; i++) {
                this._originalLineTexts[i] = lines[i].textContent;
            }
        }
        
        // Process each line
        for (let i = 0; i < lines.length; i++) {
            // Skip if already processed
            if (lines[i].querySelector('span')) continue;
            
            const text = this._originalLineTexts[i] || lines[i].textContent;
            let wrappedText = '';
            
            // Create sequential delays for letter-by-letter animation
            for (let j = 0; j < text.length; j++) {
                const delay = j * 0.05; // Sequential delay based on letter position
                const char = text[j];
                
                if (char === ' ') {
                    wrappedText += `<span style="animation-delay: ${delay}s; display: inline-block; width: 0.3em;">&nbsp;</span>`;
                } else {
                    wrappedText += `<span style="animation-delay: ${delay}s;">${char}</span>`;
                }
            }
            
            // Update the content with wrapped letters
            lines[i].innerHTML = wrappedText;
        }
    }
    
    /**
     * Prepare the word-by-word effect by wrapping each word in a span
     * @private
     */
    _prepareWordByWordEffect() {
        if (!this.lyricsContainer) return;
        
        // Get all lyric lines
        const lines = this.lyricsContainer.getElementsByClassName('lyric-line');
        
        // Flag to track if we've wrapped words
        this._hasWrappedLetters = true;
        
        // Store original text for later unwrapping if needed
        if (!this._originalLineTexts) {
            this._originalLineTexts = [];
            for (let i = 0; i < lines.length; i++) {
                this._originalLineTexts[i] = lines[i].textContent;
            }
        }
        
        // Process each line
        for (let i = 0; i < lines.length; i++) {
            // Skip if already processed
            if (lines[i].querySelector('span')) continue;
            
            const text = this._originalLineTexts[i] || lines[i].textContent;
            const words = text.split(' ');
            let wrappedText = '';
            
            // Create sequential delays for word-by-word animation
            for (let j = 0; j < words.length; j++) {
                const delay = j * 0.15; // Sequential delay based on word position
                wrappedText += `<span class="word" style="animation-delay: ${delay}s;">${words[j]}</span> `;
            }
            
            // Update the content with wrapped words
            lines[i].innerHTML = wrappedText;
        }
    }
    
    /**
     * Add data-text attributes for transitions that use pseudo-elements
     * @private
     */
    _prepareDataTextAttributes() {
        if (!this.lyricsContainer) return;
        
        // Get all lyric lines
        const lines = this.lyricsContainer.getElementsByClassName('lyric-line');
        
        // For each line, add the data-text attribute with the line's text content
        for (let i = 0; i < lines.length; i++) {
            const lineText = lines[i].textContent;
            lines[i].setAttribute('data-text', lineText);
        }
    }
    
    /**
     * Prepare all lines for Matrix effect by wrapping each letter in spans
     * @private
     */
    _prepareMatrixEffect() {
        if (!this.lyricsContainer) return;
        
        // Get all lyric lines
        const lines = this.lyricsContainer.getElementsByClassName('lyric-line');
        
        // Flag to track if we've wrapped letters
        this._hasWrappedLetters = true;
        
        // Store original text for later unwrapping if needed
        if (!this._originalLineTexts) {
            this._originalLineTexts = [];
            for (let i = 0; i < lines.length; i++) {
                this._originalLineTexts[i] = lines[i].textContent;
                
                // Проверяем целостность текста, если необходимо - восстанавливаем из lyrics
                if (lines[i].textContent.indexOf(' ') === -1 && lines[i].textContent.length > 20) {
                    console.log("Проблема с текстом строки, восстанавливаем из lyrics:", i);
                    if (i < this.lyrics.length) {
                        lines[i].textContent = this.lyrics[i];
                        this._originalLineTexts[i] = this.lyrics[i];
                    }
                }
            }
        }
        
        // Process each line
        for (let i = 0; i < lines.length; i++) {
            // Skip if already processed
            if (lines[i].querySelector('span')) continue;
            
            const text = this._originalLineTexts[i] || lines[i].textContent;
            let wrappedText = '';
            
            // Create random delays for letter dropping effect
            for (let j = 0; j < text.length; j++) {
                const delay = Math.random() * 0.5; // Random delay between 0 and 500ms
                const char = text[j];
                // Сохраняем пробелы как отдельные span-элементы с пробелом
                if (char === ' ') {
                    wrappedText += `<span style="animation-delay: ${delay}s; display: inline-block; width: 0.3em;">&nbsp;</span>`;
                } else {
                    wrappedText += `<span style="animation-delay: ${delay}s; display: inline-block;">${char}</span>`;
                }
            }
            
            // Update the content with wrapped letters
            lines[i].innerHTML = wrappedText;
        }
    }
    
    /**
     * Unwrap letters by restoring original text
     * @private
     */
    _unwrapLetters() {
        if (!this.lyricsContainer || !this._originalLineTexts) return;
        
        // Get all lyric lines
        const lines = this.lyricsContainer.getElementsByClassName('lyric-line');
        
        // Restore original text to each line
        for (let i = 0; i < lines.length; i++) {
            if (i < this._originalLineTexts.length) {
                lines[i].textContent = this._originalLineTexts[i];
            }
        }
        
        // Reset flag
        this._hasWrappedLetters = false;
    }
    
    /**
     * Scroll to the active lyric line
     * @private
     */
    _scrollToActiveLine() {
        if (!this.containerElement || !this.currentLyricElement) return;
        
        // ADDED: Check for Rehearsal mode with blocks
        const isInRehearsalModeWithBlocksCheck = this.currentStyle && 
                                          this.currentStyle.id === 'rehearsal' && 
                                          this.textBlocks && 
                                          this.textBlocks.length > 0;
        
        const isEditModeCheck = document.body.classList.contains('waveform-active');

        if (isInRehearsalModeWithBlocksCheck && !isEditModeCheck) { // MODIFIED: Don't scroll lines in Rehearsal unless in Edit/Sync mode
            // In rehearsal mode (non-edit), we don't scroll to individual lines, only to blocks.
            return; 
        }
        
        // Check if enough time has passed since last manual scroll
        const now = Date.now();
        const timeSinceLastScroll = now - this.lastScrollTime;
        
        // Only auto-scroll if it's been more than 3 seconds since last manual scroll
        if (timeSinceLastScroll > 3000) {
            // Calculate the target scroll position
        const containerHeight = this.containerElement.clientHeight;
            const lineTop = this.currentLyricElement.offsetTop;
            const lineHeight = this.currentLyricElement.offsetHeight;
        
            // Center the line in the container
            let scrollTarget = lineTop - (containerHeight / 2) + (lineHeight / 2);
        
            // Clamp scroll target to valid range
            scrollTarget = Math.max(0, scrollTarget);
        const maxScroll = this.containerElement.scrollHeight - containerHeight;
        scrollTarget = Math.min(scrollTarget, maxScroll);
        
            // Set scroll position
        this.containerElement.scrollTo({
            top: scrollTarget,
            behavior: 'smooth'
        });
    }
    }
    
    /**
     * Sanitizes the lyrics text to ensure proper display
     * @param {string} text - The raw lyrics text
     * @returns {string} - The sanitized text
     * @private
     */
    _sanitizeLyricsText(text) {
        if (!text) return '';

        // Log original input for debugging
        console.log(`Sanitizing lyrics, length: ${text.length}`);
        
        // Remove RTF artifacts
        let cleaned = text.replace(/\\[a-zA-Z0-9]+(-?[0-9]+)?\s?/g, '');
        cleaned = cleaned.replace(/Helvetica-Bold\d*;?/g, '');
        cleaned = cleaned.replace(/Helvetica\d*;?/g, '');
        cleaned = cleaned.replace(/Times-Roman\d*;?/g, '');
        cleaned = cleaned.replace(/Arial\d*;?/g, '');
        
        // Clean up multiple spaces
        cleaned = cleaned.replace(/\s{2,}/g, ' ');
        
        // Analyze line structure to improve formatting of verses
        const lines = cleaned.split('\n');
        const structuredLines = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Skip empty lines
            if (!line) continue;
            
            // Check if line seems too long and might be multiple verses
            // Examples: "В первый день весны На краешке земли Нечаянно мы встретились с тобой."
            if (line.length > 40 && !line.startsWith('[')) {
                // Try to identify specific song patterns for the Meladze song
                const meladzePattern = /(В первый день (?:весны|зимы))\s+(На краешке земли)\s+(Нечаянно (?:мы встретились|расстались мы) с тобой\.)/i;
                if (meladzePattern.test(line)) {
                    const parts = line.match(meladzePattern);
                    if (parts && parts.length >= 4) {
                        structuredLines.push(parts[1]);
                        structuredLines.push(parts[2]);
                        structuredLines.push(parts[3]);
                        continue;
                    }
                }
                
                // Check for 3-line pattern based on the line length
                const threeLinePattern = /([^.!?]+\s)([^.!?]+\s)([^.!?]+[.!?])/;
                if (threeLinePattern.test(line)) {
                    const parts = line.match(threeLinePattern);
                    if (parts && parts.length >= 4) {
                        // Check if each part is a reasonable length for a verse line
                        if (parts[1].length > 5 && parts[2].length > 5 && parts[3].length > 5) {
                            structuredLines.push(parts[1].trim());
                            structuredLines.push(parts[2].trim());
                            structuredLines.push(parts[3].trim());
                            continue;
                        }
                    }
                }
                
                // Handle specific patterns with two clauses in a line
                const twoPartPattern = /([^,;]+[,;])\s+([^.!?]+[.!?])/;
                if (twoPartPattern.test(line)) {
                    const parts = line.match(twoPartPattern);
                    if (parts && parts.length >= 3) {
                        structuredLines.push(parts[1].trim());
                        structuredLines.push(parts[2].trim());
                        continue;
                    }
                }
                
                // Split by heuristic approach (based on length and spaces)
                if (line.length > 60) {
                    const splitPoints = this._findOptimalSplitPoints(line);
                    if (splitPoints.length > 0) {
                        let lastPos = 0;
                        for (const pos of splitPoints) {
                            structuredLines.push(line.substring(lastPos, pos).trim());
                            lastPos = pos;
                        }
                        structuredLines.push(line.substring(lastPos).trim());
                        continue;
                    }
                }
            }
            
            // If no splitting was applied, add the original line
            structuredLines.push(line);
        }
        
        // Join lines back together with proper line breaks
        cleaned = structuredLines.join('\n');
        
        // Remove any trailing/leading whitespace
        cleaned = cleaned.trim();
        
        // Specific fix for "Leave Out All The Rest" artifacts before final trim and log
        // Remove a line that is exactly ;;;; (and any whitespace around it on that line)
        cleaned = cleaned.replace(/^\s*;;;;\s*(\r?\n|$)/gm, '');
        // Remove leading \\*;;;; from the beginning of any line, preserving subsequent text
        cleaned = cleaned.replace(/^\\\*;;;;\s*/gm, '');

        // Remove trailing backslashes from an RTF file that appear at the end of lines
        cleaned = cleaned.replace(/\\(\r?\n|$)/gm, '$1');

        // Further cleanup: remove lines that are only semicolons or whitespace
        cleaned = cleaned.split('\n').map(line => {
            // Trim the line first
            const trimmedLine = line.trim();
            // If line consists only of semicolons, or is empty after trim, make it empty
            if (/^;+$/.test(trimmedLine) || trimmedLine === '') {
                return '';
            }
            return line; // Keep original line if it's not just semicolons
        }).filter(line => line !== '') // Remove genuinely empty lines that resulted from cleanup
          .join('\n');

        // Remove any leading/trailing semicolons from lines that have other text
        cleaned = cleaned.split('\n').map(line => {
            return line.replace(/^[\s;]+|[\s;]+$/g, '');
        }).join('\n');
        
        // Remove common RTF prefix artifacts like \\*;; or similar from the beginning of lines
        cleaned = cleaned.split('\n').map(line => {
            // Regex to match patterns like \\*;;, \\*;, \\*:, etc. possibly followed by spaces
            // Also handles specific known RTF prefixes
            return line.replace(/^\\(?:pardirnatural\\partightenfactor0|pard\\tx\d+\\tx\d+|[a-zA-Z0-9*]+(?:;+|:)?)\s*/, '');
        }).join('\n');
        
        // Final trim and remove multiple newlines that might have formed
        cleaned = cleaned.replace(/\n{2,}/g, '\n').trim();

        console.log(`Sanitized lyrics, final length: ${cleaned.length}, lines: ${cleaned.split('\n').length}`);
        return cleaned.trim();
    }
    
    /**
     * Find optimal points to split a long line of text into multiple lines
     * @param {string} line - The line to split
     * @returns {number[]} - Array of split positions
     * @private
     */
    _findOptimalSplitPoints(line) {
        if (!line || line.length < 40) return [];
        
        const splitPoints = [];
        const targetLength = 25; // Target length for each line
        
        // Try to find natural breaks at spaces, aiming for 25-30 char lines
        for (let i = 1; i < 3; i++) { // For 2 split points (3 lines total)
            const targetPosition = i * targetLength;
            
            // Look for a space +-5 characters from the target position
            let bestPos = -1;
            let minDistance = Infinity;
            
            for (let j = Math.max(0, targetPosition - 8); j <= Math.min(line.length - 1, targetPosition + 8); j++) {
                if (line[j] === ' ') {
                    const distance = Math.abs(j - targetPosition);
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestPos = j;
                    }
                }
            }
            
            if (bestPos > 0) {
                splitPoints.push(bestPos);
            }
        }
        
        return splitPoints;
    }

    // --- Block Management Methods ---

    enableBlockMode(editorLinesContainer = null) {
        this.isInBlockMode = true;
        this.currentBlockCreation = [];
        console.log("Block Mode Enabled. Editor Target:", editorLinesContainer);
        // TODO: Add UI logic to show '+' buttons in editorLinesContainer
        // This will likely involve iterating over lines in the editor and adding controls.
        // This method might be better placed in waveform-editor.js to handle DOM manipulations there,
        // and call lyricsDisplay for state management.
    }

    disableBlockMode(editorLinesContainer = null) {
        this.isInBlockMode = false;
        this.currentBlockCreation = [];
        console.log("Block Mode Disabled. Editor Target:", editorLinesContainer);
        // TODO: Add UI logic to hide '+' buttons
    }

    addLineToCreatingBlock(lineIndex) {
        if (!this.isInBlockMode) return;
        if (!this.currentBlockCreation.includes(lineIndex)) {
            this.currentBlockCreation.push(lineIndex);
            this.currentBlockCreation.sort((a, b) => a - b); // Keep indices sorted
            console.log("Added line to current block:", lineIndex, this.currentBlockCreation);
            // TODO: Update UI for the line in editor to show it's selected
        }
    }

    removeLineFromCreatingBlock(lineIndex) {
        if (!this.isInBlockMode) return;
        const indexInCreation = this.currentBlockCreation.indexOf(lineIndex);
        if (indexInCreation > -1) {
            this.currentBlockCreation.splice(indexInCreation, 1);
            console.log("Removed line from current block:", lineIndex, this.currentBlockCreation);
            // TODO: Update UI for the line in editor
        }
    }

    finalizeCurrentBlock(blockName) {
        const MAX_LINES_PER_BLOCK = 8; // Set to 8 as per user request

        // Use the correct array: this.currentBlockCreation
        if (!this.currentBlockCreation || this.currentBlockCreation.length === 0) {
            console.warn("Attempted to finalize an empty block.");
            // Optionally show a notification to the user
            if (typeof showNotification === 'function') {
                showNotification("Cannot create an empty block.", "warning");
            }
            return;
        }

        // Use the correct array: this.currentBlockCreation
        if (this.currentBlockCreation.length > MAX_LINES_PER_BLOCK) {
             console.warn(`Attempted to finalize a block with ${this.currentBlockCreation.length} lines. Maximum allowed is ${MAX_LINES_PER_BLOCK}.`);
            // Show notification to the user
            if (typeof showNotification === 'function') {
                 showNotification(`Blocks cannot contain more than ${MAX_LINES_PER_BLOCK} lines. Please reduce the number of lines.`, "warning");
            }
            return; // Stop finalization if the block is too large
        }


        const blockId = `block-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
        const blockData = {
            id: blockId,
            name: blockName || `Block ${this.textBlocks.length + 1}`,
            // Use the correct array: this.currentBlockCreation
            lineIndices: [...this.currentBlockCreation] 
        };
        this.textBlocks.push(blockData);
        console.log('LyricsDisplay.finalizeCurrentBlock - Current blocks after push:', JSON.stringify(this.textBlocks)); // Added for debugging
        
        // Clear the correct array after finalization
        this.currentBlockCreation = []; 
        
        console.log("Block finalized:", blockData);
        // TODO: Update "Defined Blocks\" UI list
        // TODO: Potentially refresh block buttons in editor if lines are now part of a finalized block
        this._renderTextBlocksUI(); // Placeholder for UI update
        return blockData;
    }

    clearAllTextBlocks() {
        console.trace("LyricsDisplay.clearAllTextBlocks called"); // Added for debugging
        this.textBlocks = [];
        this.currentBlockCreation = []; // Also clear any pending block
        console.log("All text blocks cleared.");
        this._renderTextBlocksUI(); // Placeholder for UI update
        // TODO: Update "Defined Blocks" UI list to be empty
    }
