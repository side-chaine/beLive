/**
 * 🎹 Piano Keyboard Integration Module for beLive
 * Упрощенная система без тестовых режимов
 */

class PianoKeyboard {
    constructor() {
        this.isActive = false;
        this.canvas = null;
        this.ctx = null;
        this.renderLoop = null;
        
        // Система анализа звука
        this.audioContext = null;
        this.analyser = null;
        this.pitchDetector = null;
        this.inputBuffer = null;
        this.bufferSize = 2048;
        
        // 🎯 РЕВОЛЮЦИОННАЯ МОНОФОНИЧЕСКАЯ СИСТЕМА - только одна нота!
        this.currentActiveNote = null; // Единственная активная нота
        this.pressedKeys = new Set(); // Set для совместимости
        this.activeNotes = new Map(); // Map для совместимости
        
        // ⚡ СИСТЕМА ЕДИНСТВЕННОГО ШАРИКА с плавными переходами
        this.singleBallIndicator = null; // Единственный шарик-индикатор
        this.ballAnimation = {
            fromX: 0, fromY: 0,
            toX: 0, toY: 0,
            progress: 1.0,
            isAnimating: false,
            startTime: 0,
            duration: 150 // 150мс на переход между нотами
        };
        this.lastAnalysisTime = 0;
        this.analysisInterval = 4; // ⚡ МАКСИМАЛЬНАЯ частота - 250fps
        
        // 🎭 Система захвата микро-нюансов для монофонического голоса
        this.vocalNuances = {
            vibrato: [], // История вибрато
            slides: [], // Скольжения между нотами
            microTiming: [], // Микро-тайминги
            noteTransitions: [] // История переходов между нотами
        };
        
        // 🔇 СТРОГАЯ фильтрация для монофонического голоса
        this.harmonicFilter = {
            lastFundamental: null, // Последняя основная частота
            octaveHistory: [], // История октавных скачков
            noiseThreshold: 0.005, // Порог шума
            harmonicTolerance: 0.02 // 2% толерантность для гармоник
        };
        
        // 📊 Минимальная статистика
        this.detectionStats = {
            totalDetections: 0,
            acceptedNotes: 0,
            harmonicsRejected: 0,
            octaveJumpsRejected: 0,
            unstableFrequencyRejected: 0,
            impreciseNotesRejected: 0,
            monophonicFiltered: 0 // 🎵 Новая метрика - отфильтровано для монофонии
        };
        
        // 🎨 Единая цветовая система (один цвет для референса)
        this.REFERENCE_COLOR = '#00ff41'; // Яркий зеленый для вокальной дорожки
        
        // Автоматическая интеграция с audioEngine
        this.currentTrackHasVocals = false;
        this.isBackgroundAnalyzing = false;
        
        // История частот для анализа стабильности
        this.frequencyHistory = [];
        
        this.init();
    }

    async init() {
        console.log('🎹 Инициализация профессиональной клавиатуры...');
        
        // Ждем загрузки Pitchy
        await this.waitForPitchy();
        
        // Настраиваем обработчики событий
        this.setupEventListeners();
        
        // Автоматическое подключение к audioEngine
        this.setupAutoAudioEngineIntegration();
        
        // Создаем клавиши
        this.keys = this.generatePianoKeys();
        
        console.log('🎹 Профессиональная клавиатура готова');
    }

    async waitForPitchy() {
        return new Promise((resolve) => {
            const check = () => {
                if (window.PitchDetector) {
                    console.log('✅ Pitchy готов для клавиатуры');
                    resolve();
                } else {
                    setTimeout(check, 100);
                }
            };
            check();
        });
    }

    setupEventListeners() {
        // Обработчики клавиатуры
        this.keydownHandler = (e) => {
            if (e.code === 'Escape') {
                this.hide();
                e.preventDefault();
            }
        };
        
        this.keyupHandler = (e) => {
            // Пока ничего не делаем
        };
        
        // Обработчик кликов по canvas
        this.clickHandler = (e) => {
            if (!this.canvas) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Проверяем клик по кнопке закрытия (в правом верхнем углу)
            const closeButtonSize = 50;
            const closeButtonX = this.canvas.width - closeButtonSize;
            const closeButtonY = 0;
            
            if (x >= closeButtonX && x <= closeButtonX + closeButtonSize && 
                y >= closeButtonY && y <= closeButtonY + closeButtonSize) {
                this.hide();
                return;
            }
            
            // 🎛️ Обработка кликов по панели управления
            this.handleControlPanelClick(x, y);
        };
        
        document.addEventListener('keydown', this.keydownHandler);
        document.addEventListener('keyup', this.keyupHandler);

        // Улучшенная инициализация кнопки пианино
        const initPianoButton = () => {
            const pianoBtn = document.getElementById('piano-keyboard-btn');
            if (pianoBtn) {
                console.log('🎹 Кнопка пианино найдена, добавляем обработчик');
                pianoBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🎹 Клик по кнопке пианино');
                    this.toggle();
                });
                
                // Добавляем стили для лучшей видимости
                pianoBtn.style.background = '#4CAF50';
                pianoBtn.style.color = '#ffffff';
                
                return true;
            } else {
                console.warn('⚠️ Кнопка пианино не найдена');
                return false;
            }
        };
        
        // Пробуем найти кнопку сразу
        if (!initPianoButton()) {
            // Если не найдена, ждем загрузки DOM
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initPianoButton);
            } else {
                // DOM уже загружен, ждем немного
                setTimeout(initPianoButton, 1000);
            }
        }
    }

    setupCanvas() {
        // Создаем canvas элемент если он не существует
        if (!this.canvas) {
            this.canvas = document.createElement('canvas');
            this.canvas.id = 'piano-canvas';
            this.canvas.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                z-index: 9999 !important;
                background: rgba(0, 0, 0, 0.85) !important;
                backdrop-filter: blur(5px) !important;
                display: block !important;
                pointer-events: all !important;
            `;
            document.body.appendChild(this.canvas);
            
            // Принудительно показываем canvas
            this.canvas.style.display = 'block';
            this.canvas.style.visibility = 'visible';
            this.canvas.style.opacity = '1';
        }
        
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) {
            console.error('🎹 Не удалось получить 2D контекст');
            return;
        }
        
        console.log('🎹 Canvas инициализирован');
        
        const resize = () => {
            if (!this.canvas) return;
            
            // Устанавливаем размеры canvas на весь экран
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            
            console.log(`🎹 Canvas размер: ${this.canvas.width}x${this.canvas.height}`);
            
            // Перерисовываем
            if (this.isActive) {
                this.drawVisualization();
            }
        };
        
        resize();
        window.addEventListener('resize', resize);
        
        // Добавляем обработчик клика на canvas
        if (this.canvas) {
            this.canvas.addEventListener('click', this.clickHandler);
        }
        
        // Принудительная перерисовка после создания
        setTimeout(() => {
            if (this.isActive) {
                this.drawVisualization();
            }
        }, 100);
    }

    setupAudioContext() {
        console.log('🔊 Инициализация аудио контекста...');
        
        try {
            // Используем audioEngine контекст если возможно, иначе создаем новый
            if (window.audioEngine && window.audioEngine.audioContext) {
                this.audioContext = window.audioEngine.audioContext;
                console.log('✅ Используем audioEngine.audioContext');
            } else {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    this.audioContext = new AudioContext();
                    console.log('✅ Создан новый AudioContext');
                } else {
                    console.error('❌ AudioContext не поддерживается');
                    return false;
                }
            }

            // Создаем анализатор
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = this.bufferSize;
            this.analyser.smoothingTimeConstant = 0.0;
            
            // Создаем буферы
            this.inputBuffer = new Float32Array(this.analyser.fftSize);
            
            // Инициализируем Pitchy детектор
            if (window.PitchDetector) {
                this.pitchDetector = window.PitchDetector.forFloat32Array(this.bufferSize);
                console.log('✅ Pitchy детектор готов');
            } else {
                console.error('❌ PitchDetector не найден');
                return false;
            }
            
            return true;
            
        } catch (error) {
            console.error('❌ Ошибка инициализации аудио:', error);
            return false;
        }
    }

    setupAutoAudioEngineIntegration() {
        console.log('🔗 Настройка автоматической интеграции с audioEngine...');
        
        // 🎯 ПРИНУДИТЕЛЬНЫЙ режим анализа - всегда пытаемся подключиться
        let hasVocals = false;
        
        if (window.audioEngine) {
            try {
                // Проверяем разные способы определения вокальной дорожки
                if (typeof window.audioEngine.hasVocals === 'function') {
                    hasVocals = window.audioEngine.hasVocals();
                    console.log(`🎤 hasVocals() вернул: ${hasVocals}`);
                } else {
                    // Альтернативная проверка через vocalsGain
                    hasVocals = !!(window.audioEngine.vocalsGain || window.audioEngine._hasVocals);
                    console.log(`🎤 Альтернативная проверка вокалов: ${hasVocals}`);
                }
                
                // 🚀 ПРИНУДИТЕЛЬНОЕ включение если есть любой звук
                if (!hasVocals && window.audioEngine._isPlaying) {
                    hasVocals = true;
                    console.log(`🎤 Принудительное включение анализа (трек воспроизводится)`);
                }
                
            } catch (error) {
                console.warn('⚠️ Ошибка проверки вокальных дорожек:', error);
                // 🚀 ПРИНУДИТЕЛЬНО включаем если есть audioEngine
                hasVocals = true;
                console.log(`🎤 Принудительное включение анализа (есть audioEngine)`);
            }
        } else {
            console.warn('⚠️ audioEngine не найден');
            // 🚀 Пробуем микрофон как fallback
            hasVocals = true;
            console.log(`🎤 Попытка использования микрофона`);
        }
        
        this.currentTrackHasVocals = hasVocals;
        console.log(`🎤 Финальный статус: ${this.currentTrackHasVocals}`);
        
        // 🚀 ВСЕГДА запускаем анализ
        setTimeout(() => {
            this.startBackgroundVocalAnalysis();
        }, 500);
    }

    async startBackgroundVocalAnalysis() {
        console.log('🎤 Запуск фонового анализа вокальной дорожки...');
        
        try {
            if (!this.audioContext) {
                const setupResult = this.setupAudioContext();
                if (!setupResult) {
                    console.error('❌ Не удалось настроить аудио контекст');
                    return;
                }
            }

            // 🎯 ПРИОРИТЕТНОЕ подключение к вокальной дорожке
            let connected = false;
            
            if (window.audioEngine) {
                // 🎵 Приоритетное подключение к вокальным узлам
                const vocalNodes = [
                    window.audioEngine.vocalsGain,
                    window.audioEngine.masterGain,
                    window.audioEngine.outputGain
                ];
                
                for (const node of vocalNodes) {
                    if (node && typeof node.connect === 'function') {
                        try {
                            // Отключаем предыдущие подключения
                            if (this.analyser) {
                                this.analyser.disconnect();
                            }
                            
                            node.connect(this.analyser);
                            console.log(`✅ Подключен к ВОКАЛЬНОМУ узлу:`, node.constructor.name);
                            connected = true;
                            break;
                        } catch (error) {
                            console.warn(`⚠️ Не удалось подключиться к вокальному узлу ${node.constructor.name}:`, error);
                        }
                    }
                }
                
                // 🎵 Дополнительное подключение к инструментальным узлам (если вокал недоступен)
                if (!connected) {
                    const instrumentalNodes = [
                        window.audioEngine.instrumentalsGain,
                        window.audioEngine._audioSource,
                        window.audioEngine.gainNode
                    ];
                    
                    for (const node of instrumentalNodes) {
                        if (node && typeof node.connect === 'function') {
                            try {
                                node.connect(this.analyser);
                                console.log(`✅ Подключен к инструментальному узлу:`, node.constructor.name);
                                connected = true;
                                break;
                            } catch (error) {
                                console.warn(`⚠️ Не удалось подключиться к инструментальному узлу ${node.constructor.name}:`, error);
                            }
                        }
                    }
                }
                
                // 🎯 Последняя попытка через destination
                if (!connected && this.audioContext) {
                    try {
                        const mediaSource = this.audioContext.createMediaElementSource(window.audioEngine.audio || document.createElement('audio'));
                        mediaSource.connect(this.analyser);
                        this.analyser.connect(this.audioContext.destination);
                        console.log(`✅ Подключен через MediaElementSource`);
                        connected = true;
                    } catch (error) {
                        console.warn(`⚠️ MediaElementSource не удался:`, error);
                    }
                }
            }
            
            // 🎤 Fallback: микрофон ТОЛЬКО если нет audioEngine
            if (!connected && !window.audioEngine) {
                console.log('🎤 Попытка подключения к микрофону (нет audioEngine)...');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { 
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        } 
                    });
                    const micSource = this.audioContext.createMediaStreamSource(stream);
                    micSource.connect(this.analyser);
                    console.log(`✅ Подключен к микрофону (fallback)`);
                    connected = true;
                } catch (error) {
                    console.warn(`⚠️ Микрофон недоступен:`, error);
                }
            }
            
            if (connected) {
                this.isBackgroundAnalyzing = true;
                this.startConditionalAnalysis();
                console.log('✅ Фоновый анализ запущен');
            } else {
                console.error('❌ Не удалось подключиться ни к одному аудио источнику');
                // 🚀 Все равно запускаем анализ - возможно подключение произойдет позже
                this.isBackgroundAnalyzing = true;
                this.startConditionalAnalysis();
                console.log('⚡ Анализ запущен принудительно');
            }
            
        } catch (error) {
            console.error('❌ Ошибка запуска фонового анализа:', error);
            // 🚀 Все равно пытаемся запустить
            this.isBackgroundAnalyzing = true;
            this.startConditionalAnalysis();
            console.log('⚡ Анализ запущен аварийно');
        }
    }

    startConditionalAnalysis() {
        if (!this.isBackgroundAnalyzing) return;
        
        // ⚡ СУПЕР-БЫСТРЫЙ анализ для эффекта "игры на пианино голосом"
        const analyze = (timestamp) => {
            if (!this.isBackgroundAnalyzing) return;
            
            // ⚡ МАКСИМАЛЬНАЯ частота анализа - 250fps (4мс)
            if (timestamp - this.lastAnalysisTime >= this.analysisInterval) {
                this.lastAnalysisTime = timestamp;
                
                // 🎯 НЕПРЕРЫВНЫЙ анализ при воспроизведении
                if (window.audioEngine && window.audioEngine._isPlaying) {
                    const pitchData = this.detectPitch();
                    if (pitchData) {
                        this.processNote(pitchData);
                        this.updateVocalNuances(pitchData); // 🎭 Захват нюансов
                    } else {
                        // 🔇 МГНОВЕННАЯ проверка тишины
                        this.checkForSilenceInstant(timestamp);
                    }
                } else {
                    // 🔇 Очищаем все при остановке
                    this.forceStopAllKeys('track_stopped');
                }
            }
            
            // 🧹 НЕПРЕРЫВНАЯ очистка неактивных клавиш
            this.cleanupInactiveKeysInstant(timestamp);
            
            // Продолжаем анализ на максимальной скорости
            requestAnimationFrame(analyze);
        };
        
        // Запускаем супер-быстрый анализ
        requestAnimationFrame(analyze);
    }

    // 🎯 Проверка тишины для мгновенного отключения всех нот
    checkForSilence(currentTime) {
        if (!this.inputBuffer) return;
        
        this.analyser.getFloatTimeDomainData(this.inputBuffer);
        
        // Быстрая проверка RMS амплитуды
        let rms = 0;
        for (let i = 0; i < this.inputBuffer.length; i++) {
            rms += this.inputBuffer[i] * this.inputBuffer[i];
        }
        rms = Math.sqrt(rms / this.inputBuffer.length);
        
        // 🔇 ТОЛЬКО при полной тишине отключаем ВСЕ клавиши
        const silenceThreshold = 0.002; // Снизили порог тишины
        if (rms < silenceThreshold) {
            // Дополнительная проверка - убеждаемся что это действительно тишина
            let silenceCount = 0;
            if (!this.silenceHistory) this.silenceHistory = [];
            
            this.silenceHistory.push(rms);
            if (this.silenceHistory.length > 5) {
                this.silenceHistory.shift();
            }
            
            // Только если последние 5 замеров показывают тишину
            for (const silence of this.silenceHistory) {
                if (silence < silenceThreshold) silenceCount++;
            }
            
            if (silenceCount >= 4 && this.pressedKeys.size > 0) {
                console.log(`🔇 Глубокая тишина: очистка ${this.pressedKeys.size} нот`);
                this.pressedKeys.clear();
                this.activeNotes.clear(); // 🎯 Очищаем также activeNotes
            }
        }
    }

    // 🔇 Принудительное отключение всех клавиш для монофонии
    forceStopAllKeys(reason = 'manual') {
        if (this.currentActiveNote || this.pressedKeys.size > 0) {
            console.log(`🔇 Монофоническая очистка (${reason}): ${this.pressedKeys.size} клавиш`);
            this.currentActiveNote = null;
            this.singleBallIndicator = null; // 🎯 Очищаем единственный шарик
            this.pressedKeys.clear();
            this.activeNotes.clear();
            this.ballAnimation.isAnimating = false; // Останавливаем анимацию
            this.harmonicFilter.lastFundamental = null; // Сбрасываем фильтр
        }
    }

    stopBackgroundAnalysis() {
        console.log('🛑 Остановка фонового анализа');
        this.isBackgroundAnalyzing = false;
    }

    toggle() {
        if (this.isActive) {
            this.hide();
        } else {
            this.show();
        }
    }

    show() {
        console.log('🎹 Запуск Pitchy клавиатуры...');
        
        if (this.isActive) {
            console.log('⚠️ Клавиатура уже активна');
            return;
        }

        this.setupCanvas();
        this.setupAudioContext();
        
        // Принудительно обновляем статус интеграции при открытии
        this.updateAudioEngineStatus();
        
        this.startRender();
        this.isActive = true;
        
        console.log('✅ Pitchy клавиатура готова к работе');
    }

    // Метод для принудительного обновления статуса audioEngine
    updateAudioEngineStatus() {
        console.log('🔄 Обновление статуса audioEngine...');
        
        // Останавливаем текущий анализ если он активен
        if (this.isBackgroundAnalyzing) {
            this.stopBackgroundAnalysis();
        }
        
        // Перезапускаем интеграцию
        this.setupAutoAudioEngineIntegration();
    }

    hide() {
        console.log('🎹 Остановка Pitchy клавиатуры...');
        
        this.isActive = false;
        this.stopBackgroundAnalysis();
        
        if (this.renderLoop) {
            clearTimeout(this.renderLoop);
            this.renderLoop = null;
        }
        
        if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }
        
        this.canvas = null;
        this.ctx = null;
        
        document.removeEventListener('keydown', this.keydownHandler);
        document.removeEventListener('keyup', this.keyupHandler);
        
        console.log('✅ Pitchy клавиатура остановлена');
    }

    generatePianoKeys() {
        const keys = [];
        
        // 🎹 ПРАВИЛЬНЫЙ порядок нот в октаве
        const whiteNotes = ['C', 'D', 'E', 'F', 'G', 'A', 'B']; // 7 белых клавиш
        const blackNotes = ['C#', 'D#', 'F#', 'G#', 'A#']; // 5 черных клавиш
        
        // Генерируем клавиши от C2 до C6 (профессиональный вокальный диапазон)
        for (let octave = 2; octave <= 6; octave++) {
            // Сначала добавляем все белые клавиши октавы
            for (const note of whiteNotes) {
                const frequency = this.noteToFrequency(note, octave);
                
                // Проверяем диапазон C2-C6
                if (frequency >= 65.4 && frequency <= 1046.5) { 
                    const key = {
                        note: note,
                        octave: octave,
                        frequency: frequency,
                        isBlack: false,
                        isPressed: false,
                        x: 0, y: 0, width: 0, height: 0
                    };
                    keys.push(key);
                }
            }
            
            // Затем добавляем все черные клавиши октавы
            for (const note of blackNotes) {
                const frequency = this.noteToFrequency(note, octave);
                
                // Проверяем диапазон C2-C6
                if (frequency >= 65.4 && frequency <= 1046.5) { 
                    const key = {
                        note: note,
                        octave: octave,
                        frequency: frequency,
                        isBlack: true,
                        isPressed: false,
                        x: 0, y: 0, width: 0, height: 0
                    };
                    keys.push(key);
                }
            }
        }
        
        console.log(`🎹 Создано ${keys.length} клавиш профессионального диапазона`);
        
        // Логируем первые несколько клавиш для проверки
        const firstKeys = keys.slice(0, 12).map(k => `${k.note}${k.octave}${k.isBlack ? '(●)' : ''}`);
        console.log(`🎵 Первая октава: ${firstKeys.join(', ')}`);
        
        return keys;
    }

    noteToFrequency(note, octave) {
        const noteToSemitone = {
            'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
            'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11
        };
        
        const semitone = noteToSemitone[note];
        const A4 = 440;
        const midiNumber = octave * 12 + semitone + 12;
        
        return A4 * Math.pow(2, (midiNumber - 69) / 12);
    }

    startRender() {
        if (this.renderLoop) return;
        
        console.log('🎹 Запуск супер-быстрого цикла рендера');
        
        const render = () => {
            if (!this.isActive) {
                this.renderLoop = null;
                console.log('🎹 Остановка цикла рендера');
                return;
            }
            
            this.drawVisualization();
            
            // ⚡ Максимальный FPS для мгновенной визуализации
            const hasActiveKeys = this.pressedKeys.size > 0;
            const delay = hasActiveKeys ? 4 : 16; // 250fps для активных клавиш, 60fps в покое
            
            this.renderLoop = setTimeout(() => {
                requestAnimationFrame(render);
            }, delay);
        };
        
        this.renderLoop = requestAnimationFrame(render);
    }

    drawVisualization() {
        if (!this.ctx || !this.canvas) return;
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Темный фон для комфортного просмотра
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, 0, width, height);
        
        // Рисуем клавиши
        this.drawPianoKeyboard(width, height);
        
        // Рисуем частицы и эффекты
        this.updateAndDrawParticles();
        
        // Информационная панель
        this.drawInfoPanel(width, height);
    }

    // 🎛️ Обработка кликов по панели управления
    handleControlPanelClick(x, y) {
        // Только проверяем клик по области панели для предотвращения случайных кликов
        const panelY = 50;
        const panelHeight = 200;
        const panelWidth = 280;
        const panelX = 10;
        
        // Если клик вне панели - ничего не делаем
        if (x < panelX || x > panelX + panelWidth || y < panelY || y > panelY + panelHeight) {
            return;
        }
    }

    drawInfoPanel(width, height) {
        // Кнопка закрытия в правом верхнем углу
        const closeButtonSize = 50;
        const closeButtonX = width - closeButtonSize;
        const closeButtonY = 0;
        
        // Фон кнопки
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        this.ctx.fillRect(closeButtonX, closeButtonY, closeButtonSize, closeButtonSize);
        
        // Крестик
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.moveTo(closeButtonX + 15, closeButtonY + 15);
        this.ctx.lineTo(closeButtonX + 35, closeButtonY + 35);
        this.ctx.moveTo(closeButtonX + 35, closeButtonY + 15);
        this.ctx.lineTo(closeButtonX + 15, closeButtonY + 35);
        this.ctx.stroke();
        
        // 🎯 Панель диагностики для МОНОФОНИЧЕСКОГО анализа
        const panelX = 10;
        const panelY = 50;
        const panelWidth = 300;
        const panelHeight = 240;
        
        // Фон панели
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
        this.ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
        this.ctx.strokeStyle = '#00ff41';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
        
        // Заголовок панели
        this.ctx.fillStyle = '#00ff41';
        this.ctx.font = 'bold 16px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.fillText('🎵 МОНОФОНИЧЕСКИЙ Анализ Вокала', panelX + 10, panelY + 25);
        
        // Статистика детекции для монофонии
        const stats = this.detectionStats;
        const successRate = stats.totalDetections > 0 ? (stats.acceptedNotes / stats.totalDetections * 100).toFixed(1) : 0;
        const totalRejected = stats.harmonicsRejected + stats.octaveJumpsRejected + stats.unstableFrequencyRejected + stats.impreciseNotesRejected + stats.monophonicFiltered;
        
        const statsInfo = [
            `📊 Всего анализов: ${stats.totalDetections}`,
            `✅ Принято нот: ${stats.acceptedNotes}`,
            `🚫 Отфильтровано: ${totalRejected}`,
            `🎯 Качество: ${successRate}%`,
            `🔇 Монофильтр: ${stats.monophonicFiltered}`,
            `🎼 Гармоники: ${stats.harmonicsRejected}`
        ];
        
        // 🎯 Диагностика в реальном времени для монофонии
        if (this.isBackgroundAnalyzing && this.inputBuffer) {
            this.analyser.getFloatTimeDomainData(this.inputBuffer);
            const [frequency, clarity] = this.pitchDetector ? this.pitchDetector.findPitch(this.inputBuffer, this.audioContext.sampleRate) : [0, 0];
            
            let rms = 0;
            for (let i = 0; i < this.inputBuffer.length; i++) {
                rms += this.inputBuffer[i] * this.inputBuffer[i];
            }
            rms = Math.sqrt(rms / this.inputBuffer.length);
            
            statsInfo.push(``, `🔍 ТЕКУЩИЙ АНАЛИЗ:`);
            statsInfo.push(`📡 Частота: ${frequency ? frequency.toFixed(1) + 'Hz' : 'Тишина'}`);
            statsInfo.push(`🎯 Четкость: ${clarity ? (clarity * 100).toFixed(0) + '%' : '0%'}`);
            statsInfo.push(`📊 Сигнал: ${(rms * 1000).toFixed(1)}`);
            statsInfo.push(`🎹 Активная нота: ${this.currentActiveNote ? this.currentActiveNote.keyId : 'Нет'}`);
            statsInfo.push(`🎯 Шарик: ${this.singleBallIndicator ? 'Активен' : 'Нет'}`); // 🎯 Статус единственного шарика
            
            // 🎭 Информация о текущем шарике
            if (this.singleBallIndicator) {
                statsInfo.push(``, `🎵 ЕДИНСТВЕННЫЙ ШАРИК:`);
                const sign = this.singleBallIndicator.deviation > 0 ? '+' : '';
                statsInfo.push(`${this.singleBallIndicator.keyId}: ${this.singleBallIndicator.accuracy}% (${sign}${Math.round(this.singleBallIndicator.deviation)}¢)`);
                
                if (this.ballAnimation.isAnimating) {
                    const progress = Math.round(this.ballAnimation.progress * 100);
                    statsInfo.push(`🎭 Анимация: ${progress}%`);
                }
            }
            
            // 🎭 История переходов между нотами
            if (this.vocalNuances.noteTransitions.length > 0) {
                const lastTransition = this.vocalNuances.noteTransitions[this.vocalNuances.noteTransitions.length - 1];
                if (lastTransition.fromNote) {
                    statsInfo.push(`🎵 Последний переход: ${lastTransition.fromNote} → ${lastTransition.toNote}`);
                }
            }
        }
        
        this.ctx.fillStyle = '#cccccc';
        this.ctx.font = '10px Arial';
        statsInfo.forEach((info, index) => {
            if (info.includes('ТЕКУЩИЙ АНАЛИЗ:') || info.includes('ЕДИНСТВЕННЫЙ ШАРИК:')) {
                this.ctx.fillStyle = '#FFD700';
                this.ctx.font = 'bold 10px Arial';
            } else if (info.startsWith('📡') || info.startsWith('🎯') || info.startsWith('📊') || info.startsWith('🎹') || info.startsWith('🎭')) {
                this.ctx.fillStyle = '#90EE90';
                this.ctx.font = '10px Arial';
            } else {
                this.ctx.fillStyle = '#cccccc';
                this.ctx.font = '10px Arial';
            }
            this.ctx.fillText(info, panelX + 10, panelY + 45 + (index * 12));
        });
        
        // Статус подключения (правый верхний угол)
        this.ctx.fillStyle = this.isBackgroundAnalyzing ? '#00ff41' : '#FF5722';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'right';
        
        let statusText = '';
        if (this.isBackgroundAnalyzing && window.audioEngine) {
            const currentTime = window.audioEngine.getCurrentTime() || 0;
            const duration = window.audioEngine.duration || 0;
            const timeStr = `${this.formatTime(currentTime)}/${this.formatTime(duration)}`;
            const isPlaying = window.audioEngine._isPlaying || false;
            const playingStatus = isPlaying ? '▶️' : '⏸️';
            statusText = `🎤 МОНОФОНИЧЕСКИЙ Анализ | ${playingStatus} ${timeStr}`;
        } else {
            statusText = 'Ожидание вокальной дорожки...';
        }
        
        this.ctx.fillText(statusText, width - 60, 30);
        
        // Инструкция (внизу по центру)
        this.ctx.fillStyle = '#888888';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('ESC или ✕ для закрытия | ОДИН шарик = монофонический голос', width / 2, height - 10);
    }

    formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    drawPianoKeyboard(width, height) {
        if (!this.keys || this.keys.length === 0) return;

        // Размещаем клавиши внизу экрана
        const maxKeyboardHeight = 200;
        const keyboardHeight = Math.min(maxKeyboardHeight, height - 120);
        const keyboardY = height - keyboardHeight - 50;
        
        // 🎹 РАЗДЕЛЯЕМ клавиши на белые и черные для правильной отрисовки
        const whiteKeys = this.keys.filter(k => !k.isBlack);
        const blackKeys = this.keys.filter(k => k.isBlack);
        
        const whiteKeyWidth = width / whiteKeys.length;
        const whiteKeyHeight = keyboardHeight;
        const blackKeyWidth = whiteKeyWidth * 0.6;
        const blackKeyHeight = keyboardHeight * 0.65;

        // 🎹 СНАЧАЛА рисуем ВСЕ белые клавиши (они идут в правильном порядке)
        whiteKeys.forEach((key, index) => {
            const x = index * whiteKeyWidth;
            const y = keyboardY;
            
            // Сохраняем координаты для обработки кликов
            key.x = x;
            key.y = y;
            key.width = whiteKeyWidth;
            key.height = whiteKeyHeight;
            
            const keyId = `${key.note}${key.octave}`;
            const isPressed = this.pressedKeys.has(keyId);
            
            // Получаем данные активной ноты для цвета точности
            let noteColor = this.REFERENCE_COLOR;
            if (isPressed) {
                const activeNote = this.activeNotes.get(keyId);
                if (activeNote && activeNote.pitchAccuracy) {
                    noteColor = this.getPitchAccuracyColor(activeNote.pitchAccuracy);
                }
            }
            
            // Отрисовка белой клавиши с эффектами
            if (isPressed) {
                // 🎯 Активная клавиша - ПОЛНОЕ заполнение с цветом точности
                this.ctx.fillStyle = noteColor;
                this.ctx.shadowColor = noteColor;
                this.ctx.shadowBlur = 25;
                this.ctx.globalAlpha = 0.9;
                this.ctx.fillRect(x, y, whiteKeyWidth, whiteKeyHeight); // Убрали отступы!
                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1.0;
            } else {
                // ⚪ Обычная белая клавиша с отступами
                this.ctx.fillStyle = '#ffffff';
                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1.0;
                this.ctx.fillRect(x + 1, y, whiteKeyWidth - 3, whiteKeyHeight);
            }
            
            // Дополнительные эффекты только для неактивных клавиш
            if (!isPressed) {
                // Градиенты и тени для объема
                this.ctx.fillStyle = '#e8e8e8';
                this.ctx.fillRect(x + 1, y + whiteKeyHeight - 15, whiteKeyWidth - 3, 15);
                
                this.ctx.fillStyle = '#f8f8f8';
                this.ctx.fillRect(x + 1, y, whiteKeyWidth - 3, 20);
                
                // Обводка
                this.ctx.strokeStyle = '#dddddd';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x + 1, y, whiteKeyWidth - 3, whiteKeyHeight);
            } else {
                // Тонкая обводка для активной клавиши
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x, y, whiteKeyWidth, whiteKeyHeight);
            }
            
            // Подпись ноты
            this.ctx.fillStyle = isPressed ? '#ffffff' : '#888888';
            this.ctx.font = isPressed ? 'bold 11px Arial' : '10px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`${key.note}${key.octave}`, x + whiteKeyWidth/2, y + whiteKeyHeight - 5);
        });

        // 🎹 ЗАТЕМ рисуем черные клавиши ПОВЕРХ белых в правильных позициях
        blackKeys.forEach(key => {
            const x = this.getBlackKeyPosition(key, whiteKeys, whiteKeyWidth);
            const y = keyboardY;
            
            // Если позиция валидна
            if (x !== null && x >= 0 && x + blackKeyWidth <= width) {
                // Сохраняем координаты
                key.x = x;
                key.y = y;
                key.width = blackKeyWidth;
                key.height = blackKeyHeight;
                
                const keyId = `${key.note}${key.octave}`;
                const isPressed = this.pressedKeys.has(keyId);
                
                // Получаем данные активной ноты для цвета точности
                let noteColor = this.REFERENCE_COLOR;
                if (isPressed) {
                    const activeNote = this.activeNotes.get(keyId);
                    if (activeNote && activeNote.pitchAccuracy) {
                        noteColor = this.getPitchAccuracyColor(activeNote.pitchAccuracy);
                    }
                }
                
                // Отрисовка черной клавиши с эффектами
                if (isPressed) {
                    // 🎯 Активная черная клавиша - ПОЛНОЕ заполнение с цветом точности
                    this.ctx.fillStyle = noteColor;
                    this.ctx.shadowColor = noteColor;
                    this.ctx.shadowBlur = 20;
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.fillRect(x, y, blackKeyWidth, blackKeyHeight); // Убрали отступы!
                    this.ctx.shadowBlur = 0;
                    this.ctx.globalAlpha = 1.0;
                } else {
                    // ⚫ Обычная черная клавиша
                    this.ctx.fillStyle = '#1a1a1a';
                    this.ctx.shadowBlur = 0;
                    this.ctx.globalAlpha = 1.0;
                    this.ctx.fillRect(x, y, blackKeyWidth, blackKeyHeight);
                    
                    // Блик сверху для объема (только для неактивных)
                    this.ctx.fillStyle = '#404040';
                    this.ctx.fillRect(x, y, blackKeyWidth, 12);
                }
                
                // Подпись ноты
                this.ctx.fillStyle = isPressed ? '#ffffff' : '#cccccc';
                this.ctx.font = isPressed ? 'bold 9px Arial' : '8px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${key.note}${key.octave}`, x + blackKeyWidth/2, y + blackKeyHeight - 5);
            }
        });

        // 🎯 Отрисовка единственного шарика вместо множественных индикаторов
        this.drawPitchIndicators(whiteKeys, blackKeys, whiteKeyWidth, keyboardY, keyboardHeight);
    }

    // 🎯 Отрисовка единственного шарика вместо множественных индикаторов
    drawPitchIndicators(whiteKeys, blackKeys, whiteKeyWidth, keyboardY, keyboardHeight) {
        // 🎯 Рисуем ТОЛЬКО единственный шарик-индикатор
        this.drawSingleBallIndicator();
    }

    // 🎨 Рисуем шкалу точности под клавишей
    drawPitchScale(centerX, keyWidth, scaleY) {
        const scaleWidth = keyWidth * 0.8;
        const scaleX = centerX - scaleWidth / 2;
        
        // Основная линия шкалы
        this.ctx.strokeStyle = '#666666';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(scaleX, scaleY);
        this.ctx.lineTo(scaleX + scaleWidth, scaleY);
        this.ctx.stroke();
        
        // Центральная метка (идеальная частота)
        this.ctx.strokeStyle = '#00ff41';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, scaleY - 3);
        this.ctx.lineTo(centerX, scaleY + 3);
        this.ctx.stroke();
        
        // Боковые метки (±50 центов)
        this.ctx.strokeStyle = '#ffaa00';
        this.ctx.lineWidth = 2;
        const quarter = scaleWidth / 4;
        
        // Левая метка
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - quarter, scaleY - 2);
        this.ctx.lineTo(centerX - quarter, scaleY + 2);
        this.ctx.stroke();
        
        // Правая метка
        this.ctx.beginPath();
        this.ctx.moveTo(centerX + quarter, scaleY - 2);
        this.ctx.lineTo(centerX + quarter, scaleY + 2);
        this.ctx.stroke();
    }

    // 🎯 Рисуем шарик-индикатор точности
    drawPitchBall(ballX, ballY, indicator) {
        const { ballSize, ballColor, glowIntensity, deviation } = indicator;
        
        // 🌟 Свечение шарика зависит от четкости сигнала
        if (glowIntensity > 0.5) {
            this.ctx.shadowColor = ballColor;
            this.ctx.shadowBlur = ballSize * glowIntensity * 2;
            this.ctx.globalAlpha = 0.8;
        }
        
        // 🎯 Основной шарик
        this.ctx.fillStyle = ballColor;
        this.ctx.beginPath();
        this.ctx.arc(ballX, ballY, ballSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        // 🔍 Внутренний блик для объема
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        this.ctx.beginPath();
        this.ctx.arc(ballX - ballSize * 0.3, ballY - ballSize * 0.3, ballSize * 0.4, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Сбрасываем эффекты
        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1.0;
        
        // 📏 Линия от шарика к центру (если есть отклонение)
        if (Math.abs(deviation) > 10) { // Показываем линию только при отклонении >10 центов
            const centerX = ballX - (indicator.deviation / 100) * (indicator.ballSize * 3);
            
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.lineWidth = 1;
            this.ctx.setLineDash([2, 2]);
            this.ctx.beginPath();
            this.ctx.moveTo(centerX, ballY);
            this.ctx.lineTo(ballX, ballY);
            this.ctx.stroke();
            this.ctx.setLineDash([]); // Сбрасываем пунктир
        }
    }

    // 📊 Рисуем информацию о точности
    drawPitchInfo(centerX, infoY, indicator) {
        const { accuracy, deviation, currentFreq, targetFreq } = indicator;
        
        // 🎯 Точность в процентах
        this.ctx.fillStyle = indicator.ballColor;
        this.ctx.font = 'bold 10px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(`${accuracy}%`, centerX, infoY);
        
        // 📏 Отклонение в центах (если больше 5)
        if (Math.abs(deviation) > 5) {
            const sign = deviation > 0 ? '+' : '';
            this.ctx.fillStyle = '#cccccc';
            this.ctx.font = '8px Arial';
            this.ctx.fillText(`${sign}${Math.round(deviation)}¢`, centerX, infoY + 12);
        }
        
        // 🔊 Частота (для отладки, мелким шрифтом)
        if (Math.abs(deviation) > 20) {
            this.ctx.fillStyle = '#888888';
            this.ctx.font = '7px Arial';
            this.ctx.fillText(`${Math.round(currentFreq)}Hz`, centerX, infoY + 22);
        }
    }

    getBlackKeyPosition(blackKey, whiteKeys, whiteKeyWidth) {
        // 🎹 СТАНДАРТНОЕ позиционирование черных клавиш - точно по центру между белыми
        
        // Позиции черных клавиш в октаве (сдвинуты на 0.5 вправо для точного центрирования)
        const notePositions = {
            'C#': 1.0,  // Точно по центру между C (0) и D (1) + смещение 0.5
            'D#': 2.0,  // Точно по центру между D (1) и E (2) + смещение 0.5
            'F#': 4.0,  // Точно по центру между F (3) и G (4) + смещение 0.5
            'G#': 5.0,  // Точно по центру между G (4) и A (5) + смещение 0.5
            'A#': 6.0   // Точно по центру между A (5) и B (6) + смещение 0.5
        };
        
        const noteOffset = notePositions[blackKey.note];
        if (noteOffset === undefined) {
            console.warn(`⚠️ Неизвестная черная клавиша: ${blackKey.note}`);
            return null;
        }
        
        // Рассчитываем смещение для октавы (каждая октава = 7 белых клавиш)
        const octaveOffset = (blackKey.octave - 2) * 7; // Начинаем с октавы 2
        
        // Общая позиция в белых клавишах
        const totalWhiteKeyPosition = octaveOffset + noteOffset;
        
        // Проверяем, что позиция в пределах доступных белых клавиш
        if (totalWhiteKeyPosition < 0 || totalWhiteKeyPosition >= whiteKeys.length) {
            return null;
        }
        
        // Рассчитываем X координату черной клавиши (точно по центру с правильным смещением)
        const blackKeyWidth = whiteKeyWidth * 0.6;
        const centerX = totalWhiteKeyPosition * whiteKeyWidth;
        const blackKeyX = centerX - (blackKeyWidth / 2);
        
        return blackKeyX;
    }

    updateAndDrawParticles() {
        // 🚀 Убрали частицы для максимального быстродействия
        return;
    }

    // 🎯 Методы для работы с чувствительностью
    setSensitivity(multiplier) {
        this.sensitivity = Math.max(0.5, Math.min(2.0, multiplier));
        
        // 🎯 Подробный лог с описанием режима
        const sensitivityPercent = (this.sensitivity * 100).toFixed(0);
        let mode = '';
        if (this.sensitivity >= 1.8) mode = 'Максимальная';
        else if (this.sensitivity >= 1.4) mode = 'Высокая';
        else if (this.sensitivity >= 1.0) mode = 'Средняя';
        else if (this.sensitivity >= 0.7) mode = 'Низкая';
        else mode = 'Минимальная';
        
        console.log(`🎚️ Чувствительность: ${sensitivityPercent}% (${mode})`);
        
        // 🎯 Сбрасываем системы фильтрации при изменении чувствительности
        this.resetDetectionSystems();
        this.resetDetectionStats();
    }

    // 🎯 Сброс систем детекции для монофонии
    resetDetectionSystems() {
        this.currentActiveNote = null;
        this.singleBallIndicator = null; // 🎯 Очищаем единственный шарик
        this.activeNotes.clear();
        this.pressedKeys.clear();
        this.ballAnimation.isAnimating = false; // Останавливаем анимацию
        this.vocalNuances.vibrato = []; // 🎭 Очищаем историю нюансов
        this.vocalNuances.slides = [];
        this.vocalNuances.microTiming = [];
        this.vocalNuances.noteTransitions = [];
        this.harmonicFilter.lastFundamental = null; // Сбрасываем фильтр гармоник
        this.harmonicFilter.octaveHistory = [];
        console.log('🔄 Монофонические системы детекции сброшены');
    }

    resetDetectionStats() {
        this.detectionStats = {
            totalDetections: 0,
            acceptedNotes: 0,
            harmonicsRejected: 0,
            octaveJumpsRejected: 0,
            unstableFrequencyRejected: 0,
            impreciseNotesRejected: 0
        };
        this.frequencyHistory = [];
    }

    getCurrentSettings() {
        const mode = this.getDetectionSettings();
        return {
            minClarity: mode.minClarity,
            minRms: mode.minRms,
            requiredConfirmations: mode.requiredConfirmations,
            minNoteDuration: mode.minNoteDuration,
            dominanceThreshold: mode.dominanceThreshold
        };
    }

    // 🎯 Профессиональная система питч детекции с улучшенной чувствительностью
    detectPitch() {
        if (!this.pitchDetector || !this.inputBuffer) return null;
        
        this.analyser.getFloatTimeDomainData(this.inputBuffer);
        const [frequency, clarity] = this.pitchDetector.findPitch(this.inputBuffer, this.audioContext.sampleRate);
        
        if (!frequency || frequency <= 0) return null;
        
        this.detectionStats.totalDetections++;
        
        // 🎯 СТРОГИЙ диапазон для вокальной дорожки (C2-C6)
        const minFreq = 65.4;   // C2 - минимум для вокала
        const maxFreq = 1046.5; // C6 - максимум для вокала
        if (frequency < minFreq || frequency > maxFreq) return null;
        
        // 🎯 СМЯГЧЕННЫЕ пороги для лучшего захвата тихих и переходных моментов
        const minClarity = 0.60; // Снижен до 60% для захвата тихих моментов
        if (clarity < minClarity) return null;
        
        // 🎯 Расчет RMS амплитуды
        let rms = 0;
        for (let i = 0; i < this.inputBuffer.length; i++) {
            rms += this.inputBuffer[i] * this.inputBuffer[i];
        }
        rms = Math.sqrt(rms / this.inputBuffer.length);
        
        const minRms = 0.003; // Снижен для захвата тихих участков
        if (rms < minRms) return null;
        
        // 🎯 Облегченная проверка стабильности (только для новых нот)
        if (!this.hasActiveNoteNearFrequency(frequency) && !this.isFrequencyStable(frequency, clarity)) {
            this.detectionStats.unstableFrequencyRejected++;
            return null;
        }
        
        return { 
            frequency, 
            clarity, 
            amplitude: rms,
            timestamp: performance.now()
        };
    }

    // 🎯 Проверка наличия активной ноты рядом с частотой
    hasActiveNoteNearFrequency(frequency) {
        const toleranceHz = 20; // Расширили толерантность
        
        // 🎯 Проверяем активные ноты в activeNotes
        for (const [keyId, noteData] of this.activeNotes.entries()) {
            const freqDiff = Math.abs(frequency - noteData.targetFrequency);
            
            if (freqDiff <= toleranceHz) {
                return true;
            }
        }
        
        return false;
    }

    // 🎯 Облегченная проверка стабильности для быстрого отклика
    isFrequencyStable(frequency, clarity) {
        // Добавляем в историю
        this.frequencyHistory = this.frequencyHistory || [];
        this.frequencyHistory.push({ frequency, clarity, time: performance.now() });
        
        // Оставляем только последние 3 замера (короткая история для быстроты)
        if (this.frequencyHistory.length > 3) {
            this.frequencyHistory.shift();
        }
        
        // Для первых замеров - принимаем если качество хорошее
        if (this.frequencyHistory.length < 2) {
            return clarity >= 0.65;
        }
        
        // Быстрая проверка стабильности (отклонение не более 5%)
        const frequencies = this.frequencyHistory.map(h => h.frequency);
        const avgFreq = frequencies.reduce((a, b) => a + b) / frequencies.length;
        
        for (const freq of frequencies) {
            const deviation = Math.abs(freq - avgFreq) / avgFreq;
            if (deviation > 0.05) { // 5% максимальное отклонение (было 3%)
                return false;
            }
        }
        
        // Проверяем минимальную четкость
        const clarities = this.frequencyHistory.map(h => h.clarity);
        const avgClarity = clarities.reduce((a, b) => a + b) / clarities.length;
        
        return avgClarity >= 0.60; // Снизили до 60%
    }

    // 🎯 Улучшенная обработка нот с МОНОФОНИЧЕСКОЙ системой
    processNote(pitchData) {
        const { frequency, clarity, amplitude, timestamp } = pitchData;
        
        // 🔇 СТРОГАЯ фильтрация гармоник для монофонического голоса
        if (!this.isValidMonophonicFrequency(frequency, clarity, amplitude)) {
            return;
        }
        
        const note = this.frequencyToNoteAdvanced(frequency);
        if (!note) return;
        
        const noteId = `${note.note}${note.octave}`;
        
        // 🎯 РЕВОЛЮЦИЯ: Проверяем нужно ли сменить активную ноту
        const shouldSwitchNote = this.shouldSwitchToNewNote(noteId, frequency, clarity, amplitude);
        
        if (shouldSwitchNote) {
            // 🎵 Переключаемся на новую ноту (с анимацией)
            this.switchToMonophonicNote(noteId, frequency, clarity, amplitude, timestamp);
            this.detectionStats.acceptedNotes++;
            console.log(`🎵 Новая монофоническая нота: ${noteId} (четкость: ${(clarity * 100).toFixed(1)}%, амплитуда: ${(amplitude * 1000).toFixed(1)})`);
        } else if (this.currentActiveNote && this.currentActiveNote.keyId === noteId) {
            // 🔄 Обновляем текущую ноту
            this.updateCurrentMonophonicNote(frequency, clarity, amplitude, timestamp);
        }
    }

    // 🔇 Проверка валидности частоты для монофонического голоса
    isValidMonophonicFrequency(frequency, clarity, amplitude) {
        // 🎯 Проверка на гармоники (октавные дубли)
        if (this.harmonicFilter.lastFundamental) {
            const octaveRatios = [0.5, 2.0, 4.0, 0.25]; // Октавы ниже и выше
            
            for (const ratio of octaveRatios) {
                const harmonicFreq = this.harmonicFilter.lastFundamental * ratio;
                const deviation = Math.abs(frequency - harmonicFreq) / harmonicFreq;
                
                if (deviation < this.harmonicFilter.harmonicTolerance) {
                    this.detectionStats.harmonicsRejected++;
                    this.detectionStats.monophonicFiltered++;
                    return false; // Это гармоника, отфильтровываем
                }
            }
        }
        
        // 🔇 Проверка на шум
        if (amplitude < this.harmonicFilter.noiseThreshold) {
            this.detectionStats.monophonicFiltered++;
            return false;
        }
        
        // 🎯 Проверка минимальной четкости для монофонии
        if (clarity < 0.7) { // Повысили порог четкости для монофонии
            this.detectionStats.monophonicFiltered++;
            return false;
        }
        
        return true;
    }

    // 🎵 Проверка нужно ли переключиться на новую ноту
    shouldSwitchToNewNote(noteId, frequency, clarity, amplitude) {
        // Если нет активной ноты - определенно переключаемся
        if (!this.currentActiveNote) {
            return true;
        }
        
        // Если это та же нота - не переключаемся
        if (this.currentActiveNote.keyId === noteId) {
            return false;
        }
        
        // 🎯 Переключаемся только если новая нота ЗНАЧИТЕЛЬНО лучше
        const currentQuality = this.currentActiveNote.clarity * this.currentActiveNote.amplitude;
        const newQuality = clarity * amplitude;
        
        // Новая нота должна быть как минимум на 30% лучше
        const improvementThreshold = 1.3;
        if (newQuality > currentQuality * improvementThreshold) {
            return true;
        }
        
        // Или если текущая нота слишком старая (>200мс)
        const noteAge = Date.now() - this.currentActiveNote.lastDetection;
        if (noteAge > 200) {
            return true;
        }
        
        return false;
    }

    // 🎵 Переключение на новую монофоническую ноту
    switchToMonophonicNote(noteId, frequency, clarity, amplitude, timestamp) {
        const key = this.keys.find(k => `${k.note}${k.octave}` === noteId);
        if (!key) return;

        const targetFrequency = key.frequency;
        const pitchAccuracy = this.calculatePitchAccuracy(frequency, targetFrequency);
        
        // Сохраняем предыдущую позицию для анимации
        const previousIndicator = this.singleBallIndicator;
        
        // 🎯 Очищаем ВСЕ предыдущие состояния (строгая монофония!)
        this.pressedKeys.clear();
        this.activeNotes.clear();
        
        // Создаем ЕДИНСТВЕННУЮ активную ноту
        this.currentActiveNote = {
            keyId: noteId,
            frequency: frequency,
            currentFrequency: frequency,
            targetFrequency: targetFrequency,
            pitchAccuracy: pitchAccuracy,
            clarity: clarity,
            amplitude: amplitude,
            startTime: timestamp,
            lastDetection: timestamp,
            detectionCount: 1,
            maxClarity: clarity,
            maxAmplitude: amplitude
        };
        
        // Обновляем совместимые структуры
        this.pressedKeys.add(noteId);
        this.activeNotes.set(noteId, this.currentActiveNote);
        
        // 🎨 Создаем ЕДИНСТВЕННЫЙ шарик-индикатор с анимацией
        this.createSingleBallIndicator(previousIndicator);
        
        // 🔇 Обновляем фильтр гармоник
        this.harmonicFilter.lastFundamental = frequency;
        
        // 🎭 Записываем переход в историю
        this.vocalNuances.noteTransitions.push({
            fromNote: previousIndicator ? previousIndicator.keyId : null,
            toNote: noteId,
            timestamp: timestamp,
            frequency: frequency
        });
    }

    // 🔄 Обновление текущей монофонической ноты
    updateCurrentMonophonicNote(frequency, clarity, amplitude, timestamp) {
        if (!this.currentActiveNote) return;
        
        // Обновляем данные текущей ноты
        this.currentActiveNote.lastDetection = timestamp;
        this.currentActiveNote.currentFrequency = frequency;
        this.currentActiveNote.maxClarity = Math.max(this.currentActiveNote.maxClarity, clarity);
        this.currentActiveNote.maxAmplitude = Math.max(this.currentActiveNote.maxAmplitude, amplitude);
        this.currentActiveNote.detectionCount++;
        this.currentActiveNote.pitchAccuracy = this.calculatePitchAccuracy(frequency, this.currentActiveNote.targetFrequency);
        
        // Обновляем шарик-индикатор
        if (this.singleBallIndicator) {
            this.updateSingleBallIndicator(frequency, clarity, amplitude);
        }
        
        // Обновляем фильтр гармоник
        this.harmonicFilter.lastFundamental = frequency;
    }

    // 🎯 Поиск существующей ноты по частоте с толерантностью
    findExistingNoteByFrequency(frequency, timestamp) {
        const toleranceHz = 15; // ±15Hz толерантность для той же ноты
        const maxAge = 150; // Ищем ноты не старше 150мс
        
        // 🎯 Проверяем активные ноты в activeNotes
        for (const [keyId, noteData] of this.activeNotes.entries()) {
            const timeDiff = timestamp - noteData.lastDetection;
            if (timeDiff > maxAge) continue;
            
            // Проверяем близость частот
            const freqDiff = Math.abs(frequency - noteData.targetFrequency);
            
            if (freqDiff <= toleranceHz) {
                return { keyId, keyData: noteData, freqDiff };
            }
        }
        
        return null;
    }

    // 🎯 Обновление существующей ноты
    updateExistingNote(existingNote, frequency, clarity, amplitude, timestamp) {
        const { keyId, keyData } = existingNote;
        
        // Обновляем данные ноты в activeNotes
        keyData.lastDetection = timestamp;
        keyData.maxClarity = Math.max(keyData.maxClarity || 0, clarity);
        keyData.maxAmplitude = Math.max(keyData.maxAmplitude || 0, amplitude);
        keyData.detectionCount = (keyData.detectionCount || 1) + 1;
        keyData.currentFrequency = frequency; // 🎯 Обновляем текущую частоту
        
        // Пересчитываем точность
        keyData.pitchAccuracy = this.calculatePitchAccuracy(frequency, keyData.targetFrequency);
        
        // Логируем только важные обновления
        if (keyData.detectionCount % 10 === 0) {
            const duration = timestamp - keyData.startTime;
            console.log(`🎵 Продолжение ноты ${keyId}: ${duration.toFixed(0)}мс (${keyData.detectionCount} обновлений, точность: ${keyData.pitchAccuracy}%)`);
        }
    }

    // 🎯 Улучшенное преобразование частоты в ноту с высокой точностью
    frequencyToNoteAdvanced(frequency) {
        const A4 = 440.0;
        
        // Более точное вычисление с округлением
        const semitoneFromA4 = 12 * Math.log2(frequency / A4);
        const semitone = Math.round(semitoneFromA4);
        
        // 🎯 СТРОГАЯ проверка точности (не более 25 центов отклонения)
        const semitoneError = Math.abs(semitoneFromA4 - semitone);
        if (semitoneError > 0.25) { // Только 25 центов погрешности
            this.detectionStats.impreciseNotesRejected++;
            return null;
        }
        
        const midiNumber = 69 + semitone;
        const octave = Math.floor((midiNumber - 12) / 12);
        const noteIndex = (midiNumber - 12) % 12;
        
        // Обрабатываем отрицательные индексы
        const adjustedNoteIndex = noteIndex < 0 ? noteIndex + 12 : noteIndex;
        
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const note = notes[adjustedNoteIndex];
        
        // Строгий диапазон для вокала (C2-C6)
        if (octave < 2 || octave > 6) {
            return null;
        }
        
        return { note, octave };
    }

    // 🎯 Проверка на октавные прыжки
    isOctaveJump(currentNote, timestamp) {
        const currentNoteOnly = currentNote.note; // Без октавы
        
        // Ищем ноты той же высоты в других октавах в activeNotes
        for (const [keyId, noteData] of this.activeNotes.entries()) {
            // Извлекаем ноту из keyId (например, "C4" -> "C")
            const noteName = keyId.replace(/\d+$/, ''); // Убираем цифры в конце
            const noteOctave = parseInt(keyId.replace(/^[A-G]#?/, '')); // Извлекаем октаву
            
            if (noteName === currentNoteOnly && noteOctave !== currentNote.octave) {
                const timeDiff = timestamp - noteData.lastDetection;
                if (timeDiff < 100) { // Если менее 100мс назад была та же нота в другой октаве
                    return true;
                }
            }
        }
        
        return false;
    }

    // 🎯 Расчет стабильности частоты
    calculateFrequencyStability(frequencies) {
        if (frequencies.length < 2) return 1.0;
        
        const mean = frequencies.reduce((a, b) => a + b) / frequencies.length;
        const variance = frequencies.reduce((sum, freq) => sum + Math.pow(freq - mean, 2), 0) / frequencies.length;
        const stdDev = Math.sqrt(variance);
        
        // Коэффициент вариации (чем меньше, тем стабильнее)
        const coefficientOfVariation = stdDev / mean;
        
        // Преобразуем в стабильность (от 0 до 1)
        return Math.max(0, 1 - coefficientOfVariation * 20);
    }

    // 🎯 Адаптивное время подтверждения
    getRequiredConfirmationTime(clarity, sensitivity) {
        // Базовое время зависит от четкости и чувствительности
        const baseTime = 30; // мс
        const clarityBonus = (clarity - 0.5) * 20; // Чем четче, тем быстрее
        const sensitivityBonus = (sensitivity - 1.0) * 15; // Чем чувствительнее, тем быстрее
        
        return Math.max(10, baseTime - clarityBonus - sensitivityBonus);
    }

    // 🎯 Улучшенное преобразование частоты в ноту
    frequencyToNote(frequency) {
        const A4 = 440;
        const semitone = Math.round(12 * Math.log2(frequency / A4));
        const midiNumber = 69 + semitone;
        
        const octave = Math.floor((midiNumber - 12) / 12);
        const noteIndex = (midiNumber - 12) % 12;
        
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const note = notes[noteIndex];
        
        if (octave < 1 || octave > 7) {
            return null;
        }
        
        return { note, octave };
    }

    // 🎯 Автоматическая очистка клавиш с умной системой удержания
    cleanupInactiveKeys(currentTime) {
        let removedCount = 0;
        const keysToRemove = [];
        
        // Проверяем каждую активную ноту
        this.activeNotes.forEach((noteData, keyId) => {
            const timeSinceLastDetection = currentTime - noteData.lastDetection;
            
            // 🎯 Умное время удержания на основе качества ноты
            const holdTime = this.calculateHoldTime(noteData);
            
            if (timeSinceLastDetection > holdTime) {
                keysToRemove.push(keyId);
                const duration = noteData.lastDetection - noteData.startTime;
                console.log(`🔇 Остановлена нота: ${keyId} (${holdTime}мс после ${duration}мс звучания, точность: ${noteData.pitchAccuracy}%)`);
                removedCount++;
            }
        });

        // Удаляем неактивные ноты
        keysToRemove.forEach(keyId => {
            this.pressedKeys.delete(keyId);
            this.activeNotes.delete(keyId);
        });

        if (removedCount > 0) {
            console.log(`⚡ Очистка: ${removedCount} нот завершено`);
        }

        return removedCount;
    }

    // 🎯 Расчет времени удержания ноты на основе её характеристик
    calculateHoldTime(noteData) {
        const baseHoldTime = 80; // Базовое время удержания 80мс
        
        // Бонус за четкость (0-40мс)
        const clarityBonus = Math.round(noteData.maxClarity * 0.4); // До 40мс за 100% четкость
        
        // Бонус за продолжительность (0-50мс за долгое звучание)
        const duration = noteData.lastDetection - noteData.startTime;
        const durationBonus = Math.min(50, Math.round(duration / 100)); // 1мс бонуса за каждые 100мс звучания
        
        // Бонус за точность питча (0-30мс)
        const accuracyBonus = Math.round((noteData.pitchAccuracy - 50) * 0.6); // От 0 до 30мс за точность
        
        const finalHoldTime = baseHoldTime + clarityBonus + durationBonus + accuracyBonus;
        
        return Math.min(200, Math.max(60, finalHoldTime)); // От 60мс до 200мс
    }

    // 🎯 СИСТЕМА ТОЧНОСТИ ПИТЧА
    
    /**
     * Рассчитывает точность попадания в ноту (0-100%)
     * @param {number} detectedFreq - Обнаруженная частота
     * @param {number} targetFreq - Целевая частота ноты
     * @returns {number} Точность от 0 до 100%
     */
    calculatePitchAccuracy(detectedFreq, targetFreq) {
        // Расчет полутоновых интервалов (каждый полутон = 12-я степень из 2)
        const semitoneFactor = Math.pow(2, 1/12);
        
        // Границы ноты (±50 центов = ±половина полутона)
        const lowerBound = targetFreq / Math.pow(semitoneFactor, 0.5);
        const upperBound = targetFreq * Math.pow(semitoneFactor, 0.5);
        
        // Если частота вне границ ноты
        if (detectedFreq < lowerBound || detectedFreq > upperBound) {
            return 0;
        }
        
        // Расчет отклонения от центра в центах
        const centsDeviation = Math.abs(1200 * Math.log2(detectedFreq / targetFreq));
        
        // Максимальное отклонение = 50 центов (край ноты)
        const maxDeviation = 50;
        
        // Точность от 100% (центр) до 50% (край)
        const accuracy = Math.max(50, 100 - (centsDeviation / maxDeviation) * 50);
        
        return Math.round(accuracy);
    }
    
    /**
     * Получает цвет зеленого в зависимости от точности
     * @param {number} accuracy - Точность от 50 до 100%
     * @returns {string} Цвет в формате hex
     */
    getPitchAccuracyColor(accuracy) {
        // Нормализуем точность от 50-100% к 0-1
        const normalized = (accuracy - 50) / 50;
        
        // Градация зеленого от темного к яркому
        const colors = [
            '#00601e', // 50% - очень темный зеленый
            '#008025', // 60% - темно-зеленый  
            '#00a02c', // 70% - приглушенный
            '#00c033', // 80% - чуть темнее
            '#00e03a', // 90% - почти яркий
            '#00ff41'  // 100% - яркий зеленый
        ];
        
        // Индекс цвета (0-5)
        const colorIndex = Math.floor(normalized * 5);
        const clampedIndex = Math.max(0, Math.min(5, colorIndex));
        
        return colors[clampedIndex];
    }

    // 🎵 Система непрерывного отслеживания нот с реальным временем звучания
    activateKeyWithTracking(frequency, clarity, amplitude, stabilityScore = 1.0) {
        const keyId = this.getKeyIdFromFrequency(frequency);
        if (!keyId) return false;

        const key = this.keys.find(k => `${k.note}${k.octave}` === keyId);
        if (!key) return false;

        // 🎯 Рассчитываем точность попадания в ноту
        const targetFrequency = key.frequency;
        const pitchAccuracy = this.calculatePitchAccuracy(frequency, targetFrequency);
        
        // Если точность меньше 50%, не активируем ноту
        if (pitchAccuracy < 50) {
            return false;
        }

        // Проверяем есть ли уже активная нота с этим ID
        if (this.pressedKeys.has(keyId)) {
            // Обновляем данные существующей ноты
            const existingNote = this.activeNotes.get(keyId);
            if (existingNote) {
                existingNote.lastDetection = Date.now();
                existingNote.detectionCount++;
                existingNote.maxClarity = Math.max(existingNote.maxClarity, clarity);
                existingNote.maxAmplitude = Math.max(existingNote.maxAmplitude, amplitude);
                existingNote.stabilityScore = Math.max(existingNote.stabilityScore, stabilityScore);
                existingNote.currentFrequency = frequency; // 🎯 Обновляем текущую частоту
                existingNote.pitchAccuracy = pitchAccuracy; // 🎯 Обновляем точность
                
                // Логируем продолжение ноты каждые 10 обновлений
                if (existingNote.detectionCount % 10 === 0) {
                    const duration = existingNote.lastDetection - existingNote.startTime;
                    console.log(`🎵 Продолжение ноты ${keyId}: ${duration}мс (${existingNote.detectionCount} обновлений, точность: ${pitchAccuracy}%)`);
                }
            }
            return true;
        }

        // Создаем новую активную ноту
        this.pressedKeys.add(keyId);
        this.activeNotes.set(keyId, {
            keyId: keyId,
            frequency: frequency,
            currentFrequency: frequency, // 🎯 Текущая частота для расчета точности
            targetFrequency: targetFrequency, // 🎯 Целевая частота ноты
            pitchAccuracy: pitchAccuracy, // 🎯 Точность попадания
            clarity: clarity,
            amplitude: amplitude,
            stabilityScore: stabilityScore,
            startTime: Date.now(),
            lastDetection: Date.now(),
            detectionCount: 1,
            maxClarity: clarity,
            maxAmplitude: amplitude
        });

        console.log(`⚡ Новая нота: ${keyId} (четкость: ${clarity.toFixed(1)}%, амплитуда: ${amplitude.toFixed(1)}, точность: ${pitchAccuracy}%)`);
        return true;
    }

    getKeyIdFromFrequency(frequency) {
        // 🎯 Преобразуем частоту в ноту с высокой точностью
        const note = this.frequencyToNoteAdvanced(frequency);
        if (!note) return null;
        
        return `${note.note}${note.octave}`;
    }

    // 🔇 МГНОВЕННАЯ проверка тишины для монофонии
    checkForSilenceInstant(currentTime) {
        if (!this.inputBuffer) return;
        
        this.analyser.getFloatTimeDomainData(this.inputBuffer);
        
        // Быстрая проверка RMS амплитуды
        let rms = 0;
        for (let i = 0; i < this.inputBuffer.length; i++) {
            rms += this.inputBuffer[i] * this.inputBuffer[i];
        }
        rms = Math.sqrt(rms / this.inputBuffer.length);
        
        // 🔇 МГНОВЕННАЯ очистка при тишине для монофонии
        const silenceThreshold = 0.001;
        if (rms < silenceThreshold && this.currentActiveNote) {
            console.log(`🔇 Монофоническая тишина: очистка активной ноты ${this.currentActiveNote.keyId}`);
            this.currentActiveNote = null;
            this.singleBallIndicator = null;
            this.pressedKeys.clear();
            this.activeNotes.clear();
            this.ballAnimation.isAnimating = false;
            this.harmonicFilter.lastFundamental = null;
        }
    }

    // 🧹 МГНОВЕННАЯ очистка для монофонии
    cleanupInactiveKeysInstant(currentTime) {
        if (!this.currentActiveNote) return 0;
        
        // ⚡ СТРОГОЕ время удержания для мгновенного отклика в монофонии
        const maxHoldTime = 100; // 100мс удержания для монофонии
        
        const timeSinceLastDetection = currentTime - this.currentActiveNote.lastDetection;
        
        if (timeSinceLastDetection > maxHoldTime) {
            console.log(`🔇 Монофоническая очистка по времени: ${this.currentActiveNote.keyId} (${timeSinceLastDetection}мс)`);
            this.currentActiveNote = null;
            this.singleBallIndicator = null;
            this.pressedKeys.clear();
            this.activeNotes.clear();
            this.ballAnimation.isAnimating = false;
            this.harmonicFilter.lastFundamental = null;
            return 1;
        }

        return 0;
    }

    // 🎭 Система захвата микро-нюансов для монофонии
    updateVocalNuances(pitchData) {
        const { frequency, clarity, amplitude, timestamp } = pitchData;
        
        // 🎵 Анализ вибрато (колебания частоты) для единственной активной ноты
        this.vocalNuances.vibrato.push({ frequency, timestamp });
        if (this.vocalNuances.vibrato.length > 20) {
            this.vocalNuances.vibrato.shift(); // Оставляем последние 20 значений
        }
        
        // 🎭 Обновляем индикаторы точности для всех активных нот
        this.updatePitchIndicators(frequency, clarity, amplitude, timestamp);
    }

    // 🎯 Обновление визуальных индикаторов точности
    updatePitchIndicators(currentFrequency, clarity, amplitude, timestamp) {
        // 🎯 Для монофонии обновляем только единственный индикатор
        if (this.currentActiveNote) {
            this.updateSingleBallIndicator(currentFrequency, clarity, amplitude);
        }
    }

    // 🎯 Расчет отклонения частоты в центах
    calculateFrequencyDeviation(currentFreq, targetFreq) {
        // Отклонение в центах (-100 до +100)
        const cents = 1200 * Math.log2(currentFreq / targetFreq);
        return Math.max(-100, Math.min(100, cents)); // Ограничиваем ±100 центов
    }

    // 🎨 Создание единственного шарика-индикатора с анимацией
    createSingleBallIndicator(previousIndicator) {
        if (!this.currentActiveNote) return;

        const key = this.keys.find(k => `${k.note}${k.octave}` === this.currentActiveNote.keyId);
        if (!key) return;

        // 🎯 Рассчитываем позицию нового шарика
        const whiteKeys = this.keys.filter(k => !k.isBlack);
        const whiteKeyWidth = this.canvas.width / whiteKeys.length;
        const keyboardY = this.canvas.height - 250;
        
        let targetX, keyWidth;
        if (key.isBlack) {
            targetX = this.getBlackKeyPosition(key, whiteKeys, whiteKeyWidth);
            keyWidth = whiteKeyWidth * 0.6;
        } else {
            const whiteIndex = whiteKeys.findIndex(k => `${k.note}${k.octave}` === this.currentActiveNote.keyId);
            targetX = whiteIndex * whiteKeyWidth;
            keyWidth = whiteKeyWidth;
        }

        if (targetX === null) return;

        const centerX = targetX + keyWidth / 2;
        const ballY = keyboardY + 250 + 25; // Под клавишей

        // 🎨 Создаем новый индикатор
        this.singleBallIndicator = {
            keyId: this.currentActiveNote.keyId,
            currentFreq: this.currentActiveNote.currentFrequency,
            targetFreq: this.currentActiveNote.targetFrequency,
            deviation: this.calculateFrequencyDeviation(this.currentActiveNote.currentFrequency, this.currentActiveNote.targetFrequency),
            accuracy: this.currentActiveNote.pitchAccuracy,
            clarity: this.currentActiveNote.clarity,
            amplitude: this.currentActiveNote.amplitude,
            timestamp: this.currentActiveNote.lastDetection,
            ballSize: Math.min(15, 8 + (this.currentActiveNote.clarity * 7)), // Размер зависит от четкости
            ballColor: this.getPitchAccuracyColor(this.currentActiveNote.pitchAccuracy),
            glowIntensity: this.currentActiveNote.clarity,
            // Позиция с учетом отклонения частоты
            currentX: centerX + (this.calculateFrequencyDeviation(this.currentActiveNote.currentFrequency, this.currentActiveNote.targetFrequency) / 100) * (keyWidth * 0.4),
            currentY: ballY,
            targetCenterX: centerX
        };

        // 🎭 Настраиваем анимацию перехода
        if (previousIndicator && previousIndicator.currentX && previousIndicator.currentY) {
            // Есть предыдущий шарик - делаем плавный переход
            this.ballAnimation.fromX = previousIndicator.currentX;
            this.ballAnimation.fromY = previousIndicator.currentY;
            this.ballAnimation.toX = this.singleBallIndicator.currentX;
            this.ballAnimation.toY = this.singleBallIndicator.currentY;
            this.ballAnimation.progress = 0.0;
            this.ballAnimation.isAnimating = true;
            this.ballAnimation.startTime = performance.now();
            
            console.log(`🎭 Анимация перехода: ${previousIndicator.keyId} → ${this.currentActiveNote.keyId}`);
        } else {
            // Первый шарик - появляется мгновенно
            this.ballAnimation.progress = 1.0;
            this.ballAnimation.isAnimating = false;
        }
    }

    // 🔄 Обновление единственного шарика-индикатора
    updateSingleBallIndicator(frequency, clarity, amplitude) {
        if (!this.singleBallIndicator || !this.currentActiveNote) return;

        // Обновляем параметры шарика
        this.singleBallIndicator.currentFreq = frequency;
        this.singleBallIndicator.accuracy = this.currentActiveNote.pitchAccuracy;
        this.singleBallIndicator.clarity = clarity;
        this.singleBallIndicator.amplitude = amplitude;
        this.singleBallIndicator.timestamp = Date.now();
        this.singleBallIndicator.ballColor = this.getPitchAccuracyColor(this.currentActiveNote.pitchAccuracy);
        this.singleBallIndicator.glowIntensity = clarity;
        this.singleBallIndicator.ballSize = Math.min(15, 8 + (clarity * 7));

        // 🎯 Пересчитываем позицию на основе новой частоты
        const deviation = this.calculateFrequencyDeviation(frequency, this.currentActiveNote.targetFrequency);
        this.singleBallIndicator.deviation = deviation;
        
        // Обновляем позицию с плавным движением
        const whiteKeys = this.keys.filter(k => !k.isBlack);
        const whiteKeyWidth = this.canvas.width / whiteKeys.length;
        const key = this.keys.find(k => `${k.note}${k.octave}` === this.currentActiveNote.keyId);
        
        if (key) {
            let keyWidth;
            if (key.isBlack) {
                keyWidth = whiteKeyWidth * 0.6;
            } else {
                keyWidth = whiteKeyWidth;
            }
            
            // Новая X позиция с учетом отклонения частоты
            const newX = this.singleBallIndicator.targetCenterX + (deviation / 100) * (keyWidth * 0.4);
            
            // Плавное движение к новой позиции (сглаживание на 20%)
            this.singleBallIndicator.currentX += (newX - this.singleBallIndicator.currentX) * 0.2;
        }
    }

    // 🎯 Отрисовка единственного шарика с анимацией
    drawSingleBallIndicator() {
        if (!this.singleBallIndicator) return;

        let ballX = this.singleBallIndicator.currentX;
        let ballY = this.singleBallIndicator.currentY;

        // 🎭 Анимация перехода между нотами
        if (this.ballAnimation.isAnimating) {
            const elapsed = performance.now() - this.ballAnimation.startTime;
            this.ballAnimation.progress = Math.min(1.0, elapsed / this.ballAnimation.duration);
            
            // Плавная интерполяция (easing)
            const easeProgress = this.easeInOutCubic(this.ballAnimation.progress);
            
            ballX = this.ballAnimation.fromX + (this.ballAnimation.toX - this.ballAnimation.fromX) * easeProgress;
            ballY = this.ballAnimation.fromY + (this.ballAnimation.toY - this.ballAnimation.fromY) * easeProgress;
            
            if (this.ballAnimation.progress >= 1.0) {
                this.ballAnimation.isAnimating = false;
                ballX = this.ballAnimation.toX;
                ballY = this.ballAnimation.toY;
            }
        }

        // 🎨 Рисуем шкалу точности под клавишей
        this.drawPitchScaleForSingleBall();
        
        // 🌟 Свечение шарика зависит от четкости сигнала
        if (this.singleBallIndicator.glowIntensity > 0.5) {
            this.ctx.shadowColor = this.singleBallIndicator.ballColor;
            this.ctx.shadowBlur = this.singleBallIndicator.ballSize * this.singleBallIndicator.glowIntensity * 2.5;
            this.ctx.globalAlpha = 0.9;
        }
        
        // 🎯 Основной шарик
        this.ctx.fillStyle = this.singleBallIndicator.ballColor;
        this.ctx.beginPath();
        this.ctx.arc(ballX, ballY, this.singleBallIndicator.ballSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        // 🔍 Внутренний блик для объема
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        this.ctx.beginPath();
        const highlightSize = this.singleBallIndicator.ballSize * 0.4;
        this.ctx.arc(ballX - this.singleBallIndicator.ballSize * 0.3, ballY - this.singleBallIndicator.ballSize * 0.3, highlightSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Сбрасываем эффекты
        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1.0;
        
        // 📏 Линия от шарика к центру (если есть отклонение)
        if (Math.abs(this.singleBallIndicator.deviation) > 10) {
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([3, 3]);
            this.ctx.beginPath();
            this.ctx.moveTo(this.singleBallIndicator.targetCenterX, ballY);
            this.ctx.lineTo(ballX, ballY);
            this.ctx.stroke();
            this.ctx.setLineDash([]); // Сбрасываем пунктир
        }

        // 📊 Информация о точности
        this.drawSingleBallInfo(ballX, ballY);
        
        // 🎭 След движения шарика (если движется быстро)
        if (this.ballAnimation.isAnimating) {
            this.drawBallTrail(ballX, ballY);
        }
    }

    // 🎨 Рисуем шкалу точности для единственного шарика
    drawPitchScaleForSingleBall() {
        if (!this.singleBallIndicator || !this.currentActiveNote) return;

        const centerX = this.singleBallIndicator.targetCenterX;
        const scaleY = this.singleBallIndicator.currentY - 15;
        const key = this.keys.find(k => `${k.note}${k.octave}` === this.currentActiveNote.keyId);
        if (!key) return;

        const whiteKeys = this.keys.filter(k => !k.isBlack);
        const whiteKeyWidth = this.canvas.width / whiteKeys.length;
        let keyWidth;
        
        if (key.isBlack) {
            keyWidth = whiteKeyWidth * 0.6;
        } else {
            keyWidth = whiteKeyWidth;
        }

        const scaleWidth = keyWidth * 0.8;
        const scaleX = centerX - scaleWidth / 2;
        
        // Основная линия шкалы
        this.ctx.strokeStyle = '#666666';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(scaleX, scaleY);
        this.ctx.lineTo(scaleX + scaleWidth, scaleY);
        this.ctx.stroke();
        
        // Центральная метка (идеальная частота)
        this.ctx.strokeStyle = '#00ff41';
        this.ctx.lineWidth = 4;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, scaleY - 4);
        this.ctx.lineTo(centerX, scaleY + 4);
        this.ctx.stroke();
        
        // Боковые метки (±50 центов)
        this.ctx.strokeStyle = '#ffaa00';
        this.ctx.lineWidth = 2;
        const quarter = scaleWidth / 4;
        
        // Левая метка
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - quarter, scaleY - 2);
        this.ctx.lineTo(centerX - quarter, scaleY + 2);
        this.ctx.stroke();
        
        // Правая метка
        this.ctx.beginPath();
        this.ctx.moveTo(centerX + quarter, scaleY - 2);
        this.ctx.lineTo(centerX + quarter, scaleY + 2);
        this.ctx.stroke();
    }

    // 📊 Информация о единственном шарике
    drawSingleBallInfo(ballX, ballY) {
        if (!this.singleBallIndicator) return;
        
        // 🎯 Точность в процентах
        this.ctx.fillStyle = this.singleBallIndicator.ballColor;
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(`${this.singleBallIndicator.accuracy}%`, ballX, ballY + 25);
        
        // 📏 Отклонение в центах (если больше 5)
        if (Math.abs(this.singleBallIndicator.deviation) > 5) {
            const sign = this.singleBallIndicator.deviation > 0 ? '+' : '';
            this.ctx.fillStyle = '#cccccc';
            this.ctx.font = '10px Arial';
            this.ctx.fillText(`${sign}${Math.round(this.singleBallIndicator.deviation)}¢`, ballX, ballY + 38);
        }
        
        // 🎵 Название ноты
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.fillText(this.singleBallIndicator.keyId, ballX, ballY - 20);
    }

    // 🎭 След движения шарика
    drawBallTrail(ballX, ballY) {
        const progress = this.ballAnimation.progress;
        const trailLength = 5;
        
        for (let i = 0; i < trailLength; i++) {
            const trailProgress = Math.max(0, progress - (i * 0.1));
            if (trailProgress <= 0) break;
            
            const trailX = this.ballAnimation.fromX + (this.ballAnimation.toX - this.ballAnimation.fromX) * trailProgress;
            const trailY = this.ballAnimation.fromY + (this.ballAnimation.toY - this.ballAnimation.fromY) * trailProgress;
            
            const alpha = (1 - i / trailLength) * 0.3;
            const size = this.singleBallIndicator.ballSize * (1 - i / trailLength);
            
            this.ctx.fillStyle = `rgba(0, 255, 65, ${alpha})`;
            this.ctx.beginPath();
            this.ctx.arc(trailX, trailY, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    // 🎭 Плавная функция интерполяции
    easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
}

// Создаем глобальный экземпляр клавиатуры
window.pianoKeyboard = new PianoKeyboard();
